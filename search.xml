<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[要毕业了，说点什么吧]]></title>
      <url>http://www.foreverz.cn/2017/06/05/%E8%A6%81%E6%AF%95%E4%B8%9A%E4%BA%86,%E8%AF%B4%E7%82%B9%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>曾经看到过一句话，我们都是在离开的时候才爱上学校的，当时对这句话毫无感觉，现在快毕业了，却对这句话却深有体会啊！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>大学期间对学校很是无感啊，毕竟日复一日，年复一年的陪伴的我们的那些建的并不好看的教学楼、远离市区繁华的校园、座位稀缺的图书馆，都没给我留下什么好印象。但是离别时却非常的不舍。后来仔细思索，我初时觉得我爱上了学校其实并不真的是这所学校，而是我这四年的大学时光啊。</p>
<p>大学四年的时光非常的漫长，现在回忆起来却如此的短暂。在教室里无聊的听课、在运动场上的奔跑、在寝室里的游戏现在想来都已经没什么印象了。但是，那一次次春游秋游，西湖骑行、大清谷、乌镇、浙西大峡谷、上海、常州、苏州、宁波、舟山、青海、甘肃，不知不觉，原来我们去过了这么多地方，留下了这么多回忆。有你们，才让我的大学四年如此缤纷，有你们，才能给我留下这么多美好的回忆。我爱上了学校，但是爱上的其实是和你们一起的时光啊。</p>
<p>但这大学四年有这么多美好的回忆，也有很多的遗憾，因为大学期间错过了许多，错过了许多事，也错过了许多人。</p>
<p>记得一次社团秋游，已经说好要去，可是睡过头了，呵呵，没有去成。要不然上面的地点又能再增加一个了，但是，也还好，这次错过我也记得很清晰啊，总之是记住了。还有很多没记住的，好像有一些活动因为没人一起参加就放弃了，现在想想也想不太起来了，只是印象中有几个，都错过了，也就没了记忆。</p>
<p>至于错过的人，就放在回忆中好了。</p>
<p>曾经看到过一句话：假装对别人很宽容，其实就是自己无能，因为不敢伤害别人，就懦弱而苍白的解释成原谅。<br>因此有些时候我的做事方式会对有些人造成困扰，也不希望改变大家改变对我的印象了，从前不会回头，往后不会将就。就将它酿成一坛酒吧，是杏花村还是烧刀子，有机会再共饮。</p>
<p>2013年，我们彼此相遇，2017年，我们也要彼此错过。<br>书上说，天下没有不散的宴席。此去经年，也许会断了联系，但不要怕，书上还说了，人生何处不相逢。<br>但还是希望大家以后都能保持联系，经常聚聚，毕竟那是我们最美好的年华啊。</p>
<p>南方有嘉木，北方有相思。<br>嘉木风可摧，相思不可断。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Liveload：用Node.js实现页面热加载]]></title>
      <url>http://www.foreverz.cn/2017/01/13/%E7%94%A8Node-js%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%83%AD%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>我们在开发前端页面时，修改了样式表之后都会到浏览器手动刷新页面看修改后的效果。但是这样非常繁琐而且非常耗时。尤其是在各种设备上测试不同的浏览器时更是如此。而使用Node.js可以帮助我们实现页面热加载，点击一下保存，所有打开的页面都会刷新，是不是爽歪歪！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>我们先来回顾一下前段开发的经典流程：</p>
<ol>
<li>在多个浏览器打开页面；</li>
<li>寻找页面上需要调整的样式；</li>
<li>修改一个或多个样式；</li>
<li>手动刷新每个浏览器中的页面；</li>
<li>返回第2步。</li>
</ol>
<p>其中第4步非常的繁琐，需要在每个浏览器中手动刷新页面，如果是在移动设备上测试，就更加耗时间了。</p>
<p>但是如果能完全去掉手动刷新这一步呢？想象一下，当在文本编辑器中保存样式表时，所有打开了那个页面的浏览器都会自动重新加载这个CSS样式表。这会帮节省大量时间。</p>
<p>下面我们就使用<code>Socket.IO</code>跟Node.js的<code>fs.watchFile()</code>和<code>fs.watch()</code>函数配合，让这个想法变成现实。</p>
<p>关于<code>Socket.IO</code>大家可以看我<a href="http://foreverz.cn/2017/01/04/%E5%9F%BA%E4%BA%8Esocket-io%E7%9A%84%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8/" target="_blank" rel="external">这篇</a>翻译至官网的文章了解一下。</p>
<p><code>fs.watchfile()</code>与<code>fs.watch()</code>是Node.js中两个监测文件的API(包括内容改动和名字、时间戳等的任何变化)。</p>
<ul>
<li><code>fs.watchfile()</code>通过轮询检测文件的变化，所以它更耗资源，而且反应有个时间差；但是它是跨平台的，在所有系统上的表现都一样。</li>
<li><code>fs.watch()</code>）是通过监听操作系统提供的各种”事件”（内核发布的消息）实现的,针对每个平台做了高度优化，但在每个平台上的表现是不同的,导致这个方法不能保证在所有平台上可用。</li>
</ul>
<p>所以两种方法我都会讲到。</p>
<p>下面开始实现这个应用。</p>
<h2 id="构建web服务器"><a href="#构建web服务器" class="headerlink" title="构建web服务器"></a>构建web服务器</h2><p>我们使用<code>Koa</code>框架和<code>Socket.IO</code>结合在一起，构建一个静态Web服务器。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>首先新建一个<code>auto-reload</code>文件夹，然后在文件夹下新建一个<code>package.json</code>文件，将下面内容复制到文件中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"liveload"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">"Let the page automatically reload."</span>,</div><div class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"koa"</span>: <span class="string">"^2.0.0-alpha.7"</span>,</div><div class="line">    <span class="attr">"koa-convert"</span>: <span class="string">"^1.2.0"</span>,</div><div class="line">    <span class="attr">"koa-static"</span>: <span class="string">"^2.0.0"</span>,</div><div class="line">    <span class="attr">"socket.io"</span>: <span class="string">"^1.7.1"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后运行<code>npm install</code>安装依赖。</p>
<h3 id="编写静态服务器"><a href="#编写静态服务器" class="headerlink" title="编写静态服务器"></a>编写静态服务器</h3><p>新建<code>index.js</code>文件并将下面内容复制到文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">const</span> convert = <span class="built_in">require</span>(<span class="string">'koa-convert'</span>);</div><div class="line"><span class="keyword">const</span> statc = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</div><div class="line">app</div><div class="line">  .use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(ctx.path);</div><div class="line">    <span class="keyword">await</span> next();</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// 将服务器设置为基本的静态文件服务器</span></div><div class="line">  .use(convert(statc(__dirname)));</div><div class="line">app.listen(<span class="string">'9000'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at post 9000.'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>新建<code>index.html</code>文件并将下面内容复制到文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>liveload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/style.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is our Awesome Webpage!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"body"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">      If all the file is edited, then the server will send a message to the brower using Socket.IO telling it to refresh the page.</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>新建<code>css</code>文件夹，然后在该文件夹下新建<code>style.css</code>文件,写下如下样式:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">  <span class="attribute">color</span>:red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样静态文件服务器就搭建好了。<br>因为我使用了<code>async await</code>语法，所以<code>node 7.0</code>以上的版本可以运行 <code>node --harmony-async-await index</code> 运行脚本，<code>node 7.0</code>以下的版本就需要用<code>babel</code>来转码了,安装以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm i -S babel-core</div><div class="line">npm i -S babel-polyfill</div><div class="line">npm i -S babel-preset-es2015</div><div class="line">npm i -S babel-preset-stage-3</div></pre></td></tr></table></figure>
<p>新建<code>start.js</code>文件，然后复制以下内容到文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">"babel-core/register"</span>)(&#123;</div><div class="line">  <span class="attr">presets</span>: [<span class="string">'stage-3'</span>, <span class="string">'es2015'</span>]</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>(<span class="string">"babel-polyfill"</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">"./index.js"</span>);</div></pre></td></tr></table></figure>
<p>然后运行<code>node start</code>启动脚本。</p>
<p>启动脚本后在浏览器打开<code>localhost:9000</code>就可以看见页面了。<br>同时控制台会输出如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/</div><div class="line">/css/header.css</div></pre></td></tr></table></figure>
<p>这样脚本就会获得请求的文件，然后对每个文件进行监听。</p>
<h2 id="设置文件监听"><a href="#设置文件监听" class="headerlink" title="设置文件监听"></a>设置文件监听</h2><p>下面就是设置文件监听的方法了。</p>
<p>创建一个监听函数用来监听文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">let</span> wathcers = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatch</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (file === <span class="string">'/'</span>) file = <span class="string">'index.html'</span>;</div><div class="line">  <span class="keyword">let</span> absolute = path.join(__dirname, file);</div><div class="line">  <span class="keyword">if</span> (wathcers[absolute] === <span class="literal">true</span>) <span class="keyword">return</span>;</div><div class="line">  fs.watch(absolute, (e, filename) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">  &#125;);</div><div class="line">  wathcers[absolute] = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是用<code>fs.watch()</code>方法写的，如果用<code>fs.watchFile()</code>写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.watchFile(absolute, (curr, prev) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (curr.mtime.getTime() !== prev.mtime.getTime()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为直接访问<code>localhost:9000</code>是访问的<code>index.html</code>文件，所以解析到<code>index.html</code>；然后用<code>path.join()</code>获得文件的绝对路径，用<code>fs.watch()</code>监听。回调函数中的<code>e</code>是对文件做出的修改事件，<code>filename</code>是文件名。如果对文件进行了修改，那么就会输出<code>e</code>为：<code>change</code>。</p>
<p>为了防止重复监听，定义一个<code>wathcers</code>对象，每监听一个文件，就将这个文件放进对象中，将值设为<code>true</code>。然后前段请求的文件判断有没有监听，如果已监听就返回，不再重复监听。</p>
<p>接着修改第一个中间件如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app</div><div class="line">  .use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> file = ctx.path;</div><div class="line">    <span class="keyword">await</span> next();</div><div class="line">    createWatch(file);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>这样当你访问完了<code>localhost:9000</code>之后，对<code>index.html</code>和<code>style.css</code>做修改，都会在控制台输出：<code>change</code>。</p>
<h2 id="用Socket-IO重载"><a href="#用Socket-IO重载" class="headerlink" title="用Socket.IO重载"></a>用Socket.IO重载</h2><p>下面就是用Socket.IO向页面发送文件修改过的消息，让页面重载了。</p>
<p>首先引入<code>socket.io</code>并整合到服务器上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</div><div class="line"><span class="keyword">const</span> server = http.Server(app.callback());</div><div class="line"><span class="keyword">const</span> io = socket(server);</div><div class="line">server.listen(<span class="string">'9000'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at post 9000.'</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然后在监听函数里修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.watch(absolute, (e, filename) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (e === <span class="string">'change'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">    io.sockets.emit(<span class="string">'reload'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同时在<code>index.html</code>的<code>&lt;head&gt;</code>标签里加上如下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">   <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">const</span> socket = io();</div><div class="line">     socket.on(<span class="string">'reload'</span>, () =&gt; &#123;</div><div class="line">       <span class="built_in">window</span>.location.reload();</div><div class="line">     &#125;)</div><div class="line">   &#125;</div><div class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>好了，重启脚本然后试验了，比如说在打开<code>localhost:9000</code>后修改css文件，就会看到保存后页面就会刷新。</p>
<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><ul>
<li>index.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> convert = <span class="built_in">require</span>(<span class="string">'koa-convert'</span>);</div><div class="line"><span class="keyword">const</span> statc = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</div><div class="line"><span class="keyword">const</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</div><div class="line"><span class="keyword">const</span> server = http.Server(app.callback());</div><div class="line"><span class="keyword">const</span> io = socket(server);</div><div class="line">app</div><div class="line">  .use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> file = ctx.path;</div><div class="line">    <span class="keyword">await</span> next();</div><div class="line">    createWatch(file);</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// 将服务器设置为基本的静态文件服务器</span></div><div class="line">  .use(convert(statc(__dirname)));</div><div class="line">server.listen(<span class="string">'9000'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at post 9000.'</span>)</div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> wathcers = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatch</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (file === <span class="string">'/'</span>) file = <span class="string">'index.html'</span>;</div><div class="line">  <span class="keyword">let</span> absolute = path.join(__dirname, file);</div><div class="line">  <span class="keyword">if</span> (wathcers[absolute] === <span class="literal">true</span>) <span class="keyword">return</span>;</div><div class="line">  fs.watch(absolute, (e, filename) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (e === <span class="string">'change'</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(e);</div><div class="line">      io.sockets.emit(<span class="string">'reload'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  wathcers[absolute] = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>index.html:</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>liveload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/style.css"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> socket = io();</div><div class="line">      socket.on(<span class="string">'reload'</span>, () =&gt; &#123;</div><div class="line">        <span class="built_in">window</span>.location.reload();</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is our Awesome Webpage!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"body"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">      If all the file is edited, then the server will send a message to the brower using Socket.IO telling it to refresh the page.</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>/css/style.css:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">	<span class="attribute">color</span>:blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，打完收工。</p>
<h1 id="TOOl"><a href="#TOOl" class="headerlink" title="TOOl"></a>TOOl</h1><p>这里有我做好的一个热加载的npm包：<a href="https://www.npmjs.com/package/liveload-cli" target="_blank" rel="external">liveload-cli</a>;</p>
<p>使用方法：</p>
<p>全局安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g liveload-cli</div></pre></td></tr></table></figure>
<p>使用：</p>
<p>直接在项目目录下代开命令行，然后输入<code>llc</code>；浏览器访问<code>localhost:9000</code>加上文件名就可以了，默认是根目录<code>index.html</code>。</p>
<p>默认通过9000端口访问，也可以设置端口号：</p>
<ul>
<li>win：set PORT=端口号;</li>
<li>linux：PORT=端口号;</li>
</ul>
<p>然后你就可以解放了，再也不用手动刷新了，尽情享受码代码的乐趣吧。</p>
<p>项目持续更新中。。。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于Socket.IO的简单聊天应用]]></title>
      <url>http://www.foreverz.cn/2017/01/04/%E5%9F%BA%E4%BA%8Esocket-io%E7%9A%84%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文翻译自<a href="http://socket.io/" target="_blank" rel="external">socket.io官网</a>的<a href="http://socket.io/get-started/chat/" target="_blank" rel="external">Get Started: Chat application</a>，文中将创建一个简单的聊天应用，它几乎不需要<code>Node.js</code>或者<code>Socket.IO</code>的基础知识，所以它是所有用户的理想选择。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>翻译：<a href="http://foreverz.cn/" target="_blank" rel="external">Mervyn Zhang</a><br>校对：金炜同学</p>
<p>文中对其中的程序略有改动，全部由ES6实现，同时添加了一些注释。由于功力不够，翻译中出现的错误还请指正。</p>
<p>以下是翻译内容：</p>
<p>在本指南中，我们将创建一个简单的聊天应用，它几乎不需要<code>Node.js</code>或者<code>Socket.IO</code>的基础知识，所以它是所有用户的理想选择。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用流行的web应用程序栈，如LAMP(PHP)，编写聊天应用程序历来非常困难。它涉及轮询更改服务器和记录时间戳，因此编写软件会慢得多。</p>
<p>Sockets能提供在客户端和服务器之间的双向通信，所以一直以来是构建大多数实时聊天系统的解决方案。</p>
<p>也就是说服务器可以将消息推送到客户端，我们的想法是：每当你发一条信息，服务器会接收它并推送给其它连接的客户端。</p>
<h2 id="web框架"><a href="#web框架" class="headerlink" title="web框架"></a>web框架</h2><p>第一个目标是建立一个简单的HTML页面，提供一个表单和一个消息列表，我们将使用Node.js的web框架<code>express</code>完成这个目标，请确保Node.js已安装。</p>
<p>首先创建一个<code>package.json</code>清单文件来描述项目，建议把它放在一个专门的空目录。</p>
<blockquote>
<p>注：在我的仓库中，我命名为<code>socket-chat-example</code>，但是我把这个项目放在了01文件夹中，02…是对该项目的扩充。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"socket-chat-example"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">"my first socket.io app"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，为了便于安装我们所需要的依赖(相当于jar包)，我们会使用<code>npm install --save</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save express@4.10.2</div></pre></td></tr></table></figure>
<blockquote>
<p>注：这里是直接指定了安装4.10.2版本的express，也可以不加版本号直接安装最新版本的express：<code>npm install --save express</code>。</p>
</blockquote>
<p>现在express已经安装了，我们可以创建一个<code>index.js</code>文件来配置我们的应用程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.send(<span class="string">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">http.listen(<span class="number">3000</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个过程解释为以下几步：</p>
<ol>
<li>将express初始化为可以用来提供给HTTP服务的处理函数:<code>app</code>(见第2行)。</li>
<li>定义了一个路由处理程序，当访问我们的网站首页时调用。</li>
<li>让http服务监听3000端口。</li>
</ol>
<p>如果你运行<code>node index.js</code>，你会看到如下内容：</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/LsMcTduUg.png" alt=""></p>
<p>当你的浏览器访问<code>http://localhost:3000</code>时：</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/AOuGSHy7QM.png" alt=""></p>
<blockquote>
<p>注：我的仓库代码监听的是9000端口，因此需要访问<code>http://localhost:9000</code>，以下如是。</p>
</blockquote>
<h2 id="访问HTML"><a href="#访问HTML" class="headerlink" title="访问HTML"></a>访问HTML</h2><p>到目前为止，我们是在<code>index.js</code>中调用了<code>res.send</code>并传递了一个HTML字符串。但如果把我们整个应用的HTML都放在这里，那会看起来十分混乱。因此，我们创建一个<code>index.html</code>文件并引入它。</p>
<p>让我们使用<code>sendFile</code>重构我们的路由处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.sendFile(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然后使用以下内容填充<code>index.html</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Socket.IO chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">      * &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">box-sizing</span>: border-box; &#125;</div><div class="line">      <span class="selector-tag">body</span> &#123; <span class="attribute">font</span>: <span class="number">13px</span> Helvetica, Arial; &#125;</div><div class="line">      <span class="selector-tag">form</span> &#123; <span class="attribute">background</span>: <span class="number">#000</span>; <span class="attribute">padding</span>: <span class="number">3px</span>; <span class="attribute">position</span>: fixed; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</div><div class="line">      <span class="selector-tag">form</span> <span class="selector-tag">input</span> &#123; <span class="attribute">border</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">width</span>: <span class="number">90%</span>; <span class="attribute">margin-right</span>: .<span class="number">5%</span>; &#125;</div><div class="line">      <span class="selector-tag">form</span> <span class="selector-tag">button</span> &#123; <span class="attribute">width</span>: <span class="number">9%</span>; <span class="attribute">background</span>: <span class="built_in">rgb</span>(130, 224, 255); <span class="attribute">border</span>: none; <span class="attribute">padding</span>: <span class="number">10px</span>; &#125;</div><div class="line">      <span class="selector-id">#messages</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</div><div class="line">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span> &#123; <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>; &#125;</div><div class="line">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(odd)</span> &#123; <span class="attribute">background</span>: <span class="number">#eee</span>; &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"m"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你重新启动进程(通过点击 Control+C 并再次运行<code>node index</code>)，然后刷新窗口就会看到如下页面：</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/985FgSH2HQ.png" alt=""></p>
<h2 id="整合Socket-IO"><a href="#整合Socket-IO" class="headerlink" title="整合Socket.IO"></a>整合Socket.IO</h2><p>Socket.IO由两部分组成：</p>
<ul>
<li>整合(或依托于)Node.js HTTP Server的服务器:<code>socket.io</code></li>
<li>在浏览器端加载的客户端库:<code>socket.io-client</code></li>
</ul>
<p>在开发过程中，<code>socket.io</code>会自动为我们服务客户端，因此，现在我们只需要安装一个模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save socket.io</div></pre></td></tr></table></figure>
<p>这会安装模块并添加依赖关系到<code>package.json</code>。现在，我们在<code>index.js</code>添加下面内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</div><div class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</div><div class="line"></div><div class="line">app.get(<span class="string">''</span>, (req, res) =&gt; &#123;</div><div class="line">  res.sendfile(<span class="string">'index.html'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'a user connected'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">http.listen(<span class="number">3000</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意，我通过传递<code>http</code>(HTTP服务器)来初始化<code>socket.io</code>的一个新实例，然后监听连接sockets的<code>connection</code>事件，并将其记录到控制台。</p>
<p>现在在<code>index.html</code>中，<code>&lt;/body&gt;</code>前添加以下代码段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> socket = io();</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>加载<code>socket.io-client</code>会暴露一个全局<code>io</code>并连接。</p>
<p>注意，当我调用<code>io()</code>时，没有指定任何URL，因为他默认尝试连接到提供页面的主机。</p>
<p>如果你现在重新加载服务器和网站，你会看到控制台打印<code>a user connected</code>。<br>尝试打开多个页面，你会看到以下消息：</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/F5EBcTVDcd.png" alt=""></p>
<p>每个socket也会触发一个特殊的<code>disconnect</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'a user connected'</span>);</div><div class="line">  socket.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'user disconnected'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然后如果你刷新页面几次，你就会看到：</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/bOmy6xrJmi.png" alt=""></p>
<h2 id="Emitting事件"><a href="#Emitting事件" class="headerlink" title="Emitting事件"></a>Emitting事件</h2><p>Socket.IO背后的主要思想是你可以接受和发送你想要的任何事件和里面的任何数据。任何可以编码为JSON的对象都可以，也支持<a href="http://socket.io/blog/introducing-socket-io-1-0/#binary" target="_blank" rel="external">二进制数据</a>。</p>
<p>在用户键入消息时，我们让服务端接收并作为一个<code>chat message</code>事件，<code>index.html</code>的<code>script</code>部分应如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-1.11.1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> socket = io();</div><div class="line">  $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</div><div class="line">    $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同时在<code>index.js</code>中我们打印出来<code>chat message</code>事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</div><div class="line">  socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`message: <span class="subst">$&#123;msg&#125;</span>`</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行结果应如下:</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/a.gif" alt=""></p>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>我们的下一个目标是从服务端向其它用户发送事件。</p>
<p>为了给每个人发送事件，Socket.IO给我们提供了<code>io.emit</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">io.emit(<span class="string">'some event'</span>, &#123; <span class="attr">for</span>: <span class="string">'everyone'</span> &#125;);</div></pre></td></tr></table></figure>
<p>如果你想向每个人发送一条不包含某个socket的消息，我们有<code>broadcast</code>标志：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</div><div class="line">  socket.broadcast.emit(<span class="string">'hi'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这种情况下，为了简单起见，我们向包括发消息者在内的所有人发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</div><div class="line">  socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</div><div class="line">    io.emit(<span class="string">'chat message'</span>, msg);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在客户端，当我们捕获<code>chat message</code>事件时我们会将其显示在页面中，所有客户端javascript代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">const</span> socket = io();</div><div class="line">  $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</div><div class="line">    $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;);</div><div class="line">  socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</div><div class="line">    $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg));</div><div class="line">  &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样大约20行代码就完成了我们的聊天程序，看起来应该是下面这样：</p>
<p><img src="http://oef1ordmv.bkt.clouddn.com/b.gif" alt=""></p>
<h2 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h2><p>这里有一些改善应用程序的想法：</p>
<ul>
<li>当有人连接或断开连接时，向连接的用户广播消息;</li>
<li>添加对昵称的支持;</li>
<li>不要想发送消息的人发送自己发送的消息。相反，只要他按<code>Enter</code>键，直接添加消息;</li>
<li>添加用户正在输入功能;</li>
<li>显示谁在线;</li>
<li>添加私人消息;</li>
<li>用数据库保存消息;</li>
<li>分享您的改进！</li>
</ul>
<h2 id="获取此示例"><a href="#获取此示例" class="headerlink" title="获取此示例"></a>获取此示例</h2><p>你可以在Github上找到：<br><a href="https://github.com/rauchg/chat-example" target="_blank" rel="external">原版DEMO</a><br><a href="https://github.com/zmyforever1/NodeDemo/tree/master/12%20Socket.IO" target="_blank" rel="external">我的DEMO</a></p>
<p>原版DEMO的git地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/guille/chat-example.git</div></pre></td></tr></table></figure></the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js的nodegrass网页请求模块]]></title>
      <url>http://www.foreverz.cn/2016/12/08/Node-js%E7%9A%84nodegrass%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Node.js的网页请求有官方提供的的http模块，但是用起来过于繁琐与复杂，所以有了第三方基于http封装的nodegrass模块，简单易懂，方便使用。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h2 id="nodegrass是什么？"><a href="#nodegrass是什么？" class="headerlink" title="nodegrass是什么？"></a>nodegrass是什么？</h2><p>模块开发者的介绍是：nodegrass is a tool to process client request for Node.js，翻译过来就是nodegress是为Node.js处理客户端请求的工具。是对Node.js官方提供的http模块的二次处理封装，使Node.js更加的易于使用，下面我们就来看看nodegrass的用法。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先是nodegrass的安装方法，可以直接使用npm安装,建议安装在项目文件夹里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install nodegrass -save</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>然后就介绍Node.js的使用了。<br>下面是开发者提供的Demo,首先是get请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get request</span></div><div class="line"><span class="keyword">var</span> nodegrass = <span class="built_in">require</span>(<span class="string">'nodegrass'</span>);</div><div class="line">nodegrass.get(<span class="string">"https://github.com"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status,headers</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(status);</div><div class="line">    <span class="built_in">console</span>.log(headers);</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;,<span class="literal">null</span>,<span class="string">'utf8'</span>).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Got error: "</span> + e.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先<code>require</code>加载模块，然后就可以直接使用了。这里是get的<code>https://github.com</code>网站</p>
<p>post请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ng=<span class="built_in">require</span>(<span class="string">'nodegrass'</span>);</div><div class="line">ng.post(<span class="string">"https://api.weibo.com/oauth2/access_token"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status,headers</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> accessToken = <span class="built_in">JSON</span>.parse(data);</div><div class="line">	<span class="keyword">var</span> err = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">if</span>(accessToken.error)&#123;</div><div class="line">     	err = accessToken;</div><div class="line"> &#125;</div><div class="line"> callback(err,accessToken);</div><div class="line"> &#125;,headers,options,<span class="string">'utf8'</span>);</div></pre></td></tr></table></figure>
<p>post方法相比get方法多提供了headers请求头参数，options–post的数据，它们都是对象字面量的类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> headers = &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</div><div class="line">    <span class="string">'Content-Length'</span>:data.length</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">         <span class="attr">client_id</span> : <span class="string">'id'</span>,</div><div class="line">     <span class="attr">client_secret</span> : <span class="string">'cs'</span>,</div><div class="line">     <span class="attr">grant_type</span> : <span class="string">'authorization_code'</span>,</div><div class="line">     <span class="attr">redirect_uri</span> : <span class="string">'your callback url'</span>,</div><div class="line">     <span class="attr">code</span>: acode</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>利用nodegrass做代理服务器？……**</p>
<p>看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ng = <span class="built_in">require</span>(<span class="string">'nodegrass'</span>),</div><div class="line"> http=<span class="built_in">require</span>(<span class="string">'http'</span>),</div><div class="line"> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"> http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</div><div class="line">    <span class="keyword">if</span>(pathname === <span class="string">'/'</span>)&#123;</div><div class="line">        ng.get(<span class="string">'http://foreverz.cn/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">            res.writeHeader(<span class="number">200</span>,&#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=utf-8'</span>&#125;);</div><div class="line">            res.write(data+<span class="string">"\n"</span>);</div><div class="line">            res.end();</div><div class="line">            &#125;,<span class="string">'utf8'</span>);</div><div class="line">        &#125;</div><div class="line"> &#125;).listen(<span class="number">9000</span>);</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'server listening 9000...'</span>);</div></pre></td></tr></table></figure>
<p>就这么简单，当然代理服务器还有复杂的多，这个不算是，但至少你访问本地9000端口，看到的是不是博客主页呢？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[全屏滚动插件fullPage使用教程]]></title>
      <url>http://www.foreverz.cn/2016/11/03/%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6fullPage%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>经常在各种网站上看到全屏滚动的交互，在网页上实现了类似PPT的效果，很高大上，最近搜索了一下，发现可以实现这个效果的两个插件，但是有一个<code>fullPage</code>插件没有相关API的详细说明，自己在使用的过程中总结一下，写在这里！<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>有两个插件<code>fullPage.js</code>和<code>fullPage</code>都能实现全屏滚动，名字也是一样的，只是少了“.js”；但是两者的区别在于<code>fullPage.js</code>是基于<code>jQuery</code>库开发的，使用<code>fullPage.js</code>需要先引入<code>jQuery</code>，而<code>fullPage</code>则是原生js开发的，不需要依赖任何一个js库，可以单独使用。功能上虽然不如<code>fullPage.js</code>强大，但一般使用已经足够了，尤其是它的动画效果，你可以自由设定缩放、旋转以产生各种各样的动画效果。同时它还支持<code>fullPage.js</code>所没有的水平滚动。<br>我这里讲的就是原生<code>fullPage</code>插件的使用。</the></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h3><p>使用<code>fullPage</code>插件首先要引入fullPage文件，可以在<a href="http://alvarotrigo.com/fullPage/extensions/" target="_blank" rel="external">fullPage官网</a>上进行下载，然后通过<code>script</code>标签引用。</p>
<h3 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p><code>fullPage</code>对<code>HTML</code>语法没有什么严格的要求，只是需要一个外层元素，然后每一屏的内容放在一个子元素中，这样顺序排下来就可以,不过最好还是按照官方推荐的格式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pageContain"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page page1 current"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"contain"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- your own code here--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- ect.. --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--alternative--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"navBar"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>0<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- ect.. --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--alternative--&gt;</span></div></pre></td></tr></table></figure>
<p><code>#pageContain</code>就是外层元素，里面的每一个直接子元素都是一屏的内容；<br><code>#navBar</code>则是导航标签，用来显示当前屏幕位置和跳转到对应屏幕，可以省略；<br><code>.current</code>则是定义当前显示的页面；</p>
<h4 id="data-step页内动画"><a href="#data-step页内动画" class="headerlink" title="data-step页内动画"></a>data-step页内动画</h4><p>可以在<code>.page</code>的<code>div</code>上加上<code>data-step=n</code>属性，可以创造出不切屏的逐桢动画。<br>原理是滚动鼠标或者滑动页面时，为<code>.page</code>加上一个<code>class</code>属性为<code>step1</code>，滑动一次则增加1，一直增加到<code>n</code>，然后，就可以在CSS里利用<code>animation</code>属性添加动画了。<br>注意：使用导航条跳转时默认会回到<code>stepx</code>(x为上次浏览到的地方)，如果想跳转时重新开始，可以调用<code>callback</code>函数清除掉class：<code>stepx</code>;</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS可以自己定义样式，不过fullPage会把外层元素的每个子元素都设置为全屏，而且会可以自适应不同的屏幕。如果是行内元素，则会变为块级元素，且内容会居中。以下是一些必须的样式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">html &#123;</div><div class="line">    -ms-touch-action: none;  /* 阻止windows Phone 的默认触摸事件 */</div><div class="line">&#125;</div><div class="line">body,</div><div class="line">div &#123;</div><div class="line">	margin: 0;</div><div class="line">	padding: 0;</div><div class="line">&#125;</div><div class="line">body &#123;</div><div class="line">    width: 100%;</div><div class="line">    *cursor: default;</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div><div class="line">#pageContain &#123; /*设置超出页面部分隐藏*/</div><div class="line">    overflow: hidden;</div><div class="line">&#125;</div><div class="line">.page &#123;	/*设置页面为全屏*/</div><div class="line">    display: none;</div><div class="line">    width: 100%;</div><div class="line">    height: 100%;</div><div class="line">    overflow: hidden;</div><div class="line">    position: absolute;</div><div class="line">    top: 0;</div><div class="line">    left: 0;</div><div class="line">&#125;</div><div class="line">.current &#123; /当前页效果/</div><div class="line">    display: block;</div><div class="line">    z-index: 1;</div><div class="line">&#125;</div><div class="line">.slide &#123; /*滚动时的页面*/</div><div class="line">    display: block;</div><div class="line">    z-index: 2;</div><div class="line">&#125;</div><div class="line">.swipe &#123; /*滑动时的效果*/</div><div class="line">    display: block;</div><div class="line">    z-index: 3;</div><div class="line">    transition-duration: 0ms !important;</div><div class="line">    -webkit-transition-duration: 0ms !important;</div><div class="line">&#125;</div><div class="line">.page1 &#123;</div><div class="line">	... /*每个页面的样式*/</div><div class="line">&#125;</div><div class="line">...</div><div class="line">.step1 &#123;</div><div class="line">	... /*每页动画样式*/</div><div class="line">&#125;</div><div class="line">...</div><div class="line">#navBar &#123;</div><div class="line">	... /*导航样式*/</div><div class="line">&#125;</div><div class="line">#navBar li &#123;</div><div class="line">	... /*导航标签样式*/</div><div class="line">&#125;</div><div class="line">#navBar .active &#123;</div><div class="line">    ... /*导航条激活时的样式*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSS文件中这些样式是必须的，而且最好不要调整顺序，否则可能会有未知的错误出现。</p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>在JS文件中，则需要按照格式来进行设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> runPage = <span class="keyword">new</span> FullPage(&#123;</div><div class="line">    <span class="attr">id</span>: <span class="string">'pageContain'</span>, 							<span class="comment">// 父级元素的Id;</span></div><div class="line">    slideTime: <span class="number">800</span>, 							<span class="comment">// 每页切换时间(毫秒);</span></div><div class="line">    continuous: <span class="literal">false</span>, 							<span class="comment">// 是否循环(即能从最后页跳到第一页面);</span></div><div class="line">    effect: &#123; 									<span class="comment">// 切换动画效果;</span></div><div class="line">        transform: &#123;							<span class="comment">//CSS3转换动画;</span></div><div class="line">            translate: <span class="string">'Y'</span>, 					<span class="comment">// 'X'|'Y'|'XY'|'none'表示 X轴|Y轴|XY轴|无;</span></div><div class="line">            scale: [<span class="number">.1</span>, <span class="number">1</span>], 					<span class="comment">// [起始缩放比例, 结束时缩放比例];</span></div><div class="line">            rotate: [<span class="number">0</span>, <span class="number">0</span>], 					<span class="comment">// [起始旋转角度, 结束时旋转角度];</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">opacity</span>: [<span class="number">0</span>, <span class="number">1</span>], 						<span class="comment">// [起始透明度, 结束时透明度];</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">mode</span>: <span class="string">'wheel,touch,nav:navBar'</span>, 			<span class="comment">//  转换模式，表示 '滚轮,触摸,导航条:导航条id';</span></div><div class="line">    easing: <span class="string">'ease'</span>, 							<span class="comment">// 动画行进速度;</span></div><div class="line">    start: <span class="number">1</span>, 									<span class="comment">// 初始化时被展示的页面页码;</span></div><div class="line">    onSwipeStart : <span class="function"><span class="keyword">function</span>(<span class="params">index, thisPage</span>) </span>&#123;	<span class="comment">// 触摸开始时的回调函数;</span></div><div class="line">    	<span class="keyword">return</span> <span class="string">'stop'</span>;							<span class="comment">//此次触摸将不会生效;</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">beforeChange</span> : <span class="function"><span class="keyword">function</span>(<span class="params">index, thisPage</span>) </span>&#123;	<span class="comment">// 滑动开始时的回调函数;</span></div><div class="line">    	<span class="keyword">return</span> <span class="string">'stop'</span>;							<span class="comment">//此次滑动将还原;</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">callback</span> : <span class="function"><span class="keyword">function</span>(<span class="params">index, thisPage</span>) </span>&#123;		<span class="comment">// 滑动结束后的回调函数;</span></div><div class="line">    	alert(index);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过上面的设置基本就可以实现类似幻灯片的网页效果了。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><table>
<thead>
<tr>
<th style="text-align:center">属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">可选值</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">string</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">通过Id获取父级元素(必须)</td>
</tr>
<tr>
<td style="text-align:center">slideTime</td>
<td style="text-align:center">int</td>
<td style="text-align:center">800</td>
<td style="text-align:center"></td>
<td style="text-align:center">每页切换时间(毫秒)</td>
</tr>
<tr>
<td style="text-align:center">continuous</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true/false</td>
<td style="text-align:center">是否循环(最后页跳到第一页)</td>
</tr>
<tr>
<td style="text-align:center">effect</td>
<td style="text-align:center">object</td>
<td style="text-align:center"></td>
<td style="text-align:center">transform/opacity</td>
<td style="text-align:center">切换动画的效果</td>
</tr>
<tr>
<td style="text-align:center">mode</td>
<td style="text-align:center">string</td>
<td style="text-align:center">null</td>
<td style="text-align:center">wheel,touch,nav:navBar</td>
<td style="text-align:center">转换模式，表示’滚轮,触摸,导航条:导航条id</td>
</tr>
<tr>
<td style="text-align:center">easing</td>
<td style="text-align:center">string</td>
<td style="text-align:center"></td>
<td style="text-align:center">ease/ease-in/ease-in-out/cubic-bezier like [.33, 1.81, 1, 1]</td>
<td style="text-align:center">动画行进速度</td>
</tr>
<tr>
<td style="text-align:center">start</td>
<td style="text-align:center">int</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">初始化时被展示的页面页码</td>
</tr>
<tr>
<td style="text-align:center">onSwipeStart</td>
<td style="text-align:center">function</td>
<td style="text-align:center"></td>
<td style="text-align:center">return ‘stop’</td>
<td style="text-align:center">触摸开始时的回调函数(stop停止此次触摸)</td>
</tr>
<tr>
<td style="text-align:center">beforeChange</td>
<td style="text-align:center">function</td>
<td style="text-align:center"></td>
<td style="text-align:center">return ‘stop’</td>
<td style="text-align:center">滑动开始时的回调函数(stop还原此次滑动)</td>
</tr>
<tr>
<td style="text-align:center">callback</td>
<td style="text-align:center">function</td>
<td style="text-align:center">null</td>
<td style="text-align:center"></td>
<td style="text-align:center">滑动结束后的回调函数</td>
</tr>
</tbody>
</table>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Fullpage也提供了一些接口供开发者调用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性/方法</th>
<th style="text-align:center">使用</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.prev()</td>
<td style="text-align:center">function</td>
<td style="text-align:center">向上滚动一页/一屏</td>
</tr>
<tr>
<td style="text-align:center">.next()</td>
<td style="text-align:center">function</td>
<td style="text-align:center">向下滚动一页/一屏</td>
</tr>
<tr>
<td style="text-align:center">.thisPage()</td>
<td style="text-align:center">function</td>
<td style="text-align:center">返回当前的页码</td>
</tr>
<tr>
<td style="text-align:center">.go(num)</td>
<td style="text-align:center">function</td>
<td style="text-align:center">滚动到第 num 页</td>
</tr>
</tbody>
</table>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>fullPage</code>是一个非常简单却又很实用的插件，可以实现很炫酷的ppt效果的网页，而且借口简单，功能强大，文件也很小，才9kb，比起<code>jQuery</code>的<code>fullPage.js</code>插件虽然功能上略显逊色，但是强大的自定义属性可以有更多的发挥。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript之数组降维]]></title>
      <url>http://www.foreverz.cn/2016/11/01/JavaScript%E4%B9%8B%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>将多维数组（尤其是二维数组）转化为一维数组是业务开发中的常用逻辑，除了使用朴素的循环转换以外，我们还可以利用Javascript的语言特性和数据结构的思想实现更为简洁优雅的转换。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="二维数组降维"><a href="#二维数组降维" class="headerlink" title="二维数组降维"></a>二维数组降维</h2><p>二维数组只有两个维度，降维比较简单，也不用考虑太复杂的算法逻辑，我们看一下二维数组降维的几种方法；</p>
<h3 id="遍历降维"><a href="#遍历降维" class="headerlink" title="遍历降维"></a>遍历降维</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [</div><div class="line">    [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>],</div><div class="line">    [<span class="string">'m'</span>, <span class="string">'y'</span>],</div><div class="line">    [<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>],</div><div class="line">    [<span class="string">'!'</span>]</div><div class="line">];</div><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">0</span>; r &lt; arr.length; r++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; arr[r].length; c++) &#123;</div><div class="line">        result.push(arr[r][c]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//=&gt;[ 'h', 'e', 'l', 'l', 'o', 'm', 'y', 'w', 'o', 'r', 'l', 'd', '!' ]</span></div></pre></td></tr></table></figure>
<p>此方法思路简单，利用双重循环遍历二维数组中的每个元素并放到新数组中。</p>
<h3 id="使用concat"><a href="#使用concat" class="headerlink" title="使用concat"></a>使用concat</h3><p>利用concat方法，可以将双重循环简化为单重循环：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [</div><div class="line">    [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>],</div><div class="line">    [<span class="string">'m'</span>, <span class="string">'y'</span>],</div><div class="line">    [<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>],</div><div class="line">    [<span class="string">'!'</span>]</div><div class="line">];</div><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">0</span>, result = []; r &lt; arr.length; r++) &#123;</div><div class="line">    result = result.concat(arr[r]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//=&gt;[ 'h', 'e', 'l', 'l', 'o', 'm', 'y', 'w', 'o', 'r', 'l', 'd', '!' ]</span></div></pre></td></tr></table></figure></p>
<p>arr的每一个元素都是一个数组或参数，作为concat方法的参数，数组中的参数或每一个子元素又都会被独立插入进新数组。</p>
<h3 id="使用apply-concat"><a href="#使用apply-concat" class="headerlink" title="使用apply+concat"></a>使用apply+concat</h3><p>apply方法会调用一个函数，apply方法的第一个参数会作为被调用函数的this值，apply方法的第二个参数（一个数组，或类数组的对象）会作为被调用对象的arguments值，也就是说该数组的各个元素将会依次成为被调用函数的各个参数；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [</div><div class="line">    [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>],</div><div class="line">    [<span class="string">'m'</span>, <span class="string">'y'</span>],</div><div class="line">    [<span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>],</div><div class="line">    [<span class="string">'!'</span>]</div><div class="line">];</div><div class="line"><span class="keyword">var</span> result = <span class="built_in">Array</span>.prototype.concat.apply([], arr);</div><div class="line"><span class="built_in">console</span>.log(result); <span class="comment">//=&gt;[ 'h', 'e', 'l', 'l', 'o', 'm', 'y', 'w', 'o', 'r', 'l', 'd', '!' ]</span></div></pre></td></tr></table></figure></p>
<p>利用apply方法，只需要一行代码就可以完成二维数组降维了。</p>
<h2 id="多维数组降维"><a href="#多维数组降维" class="headerlink" title="多维数组降维"></a>多维数组降维</h2><p>多维数组就没二维数组那么简单了，因为不确定数组的深度，所以也不能进行遍历来降维，只能通过递归或者栈方法来实现。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.deepFlatten = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = []; <span class="comment">//定义保存结果的数组</span></div><div class="line">    <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, idx</span>) </span>&#123; <span class="comment">//遍历数组</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val)) &#123; <span class="comment">//判断是否为子数组</span></div><div class="line">            val.forEach(<span class="built_in">arguments</span>.callee); <span class="comment">//为子数组则递归执行</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(val); <span class="comment">//不为子数组则将值存入结果数组中</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> result; <span class="comment">//返回result数组</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">2</span>, <span class="number">2</span>],</div><div class="line">    [<span class="number">3</span>, <span class="string">'f'</span>, [<span class="string">'w'</span>, <span class="number">3</span>]], &#123; <span class="string">"name"</span>: <span class="string">'Tom'</span> &#125;</div><div class="line">];</div><div class="line"><span class="built_in">console</span>.log(arr.deepFlatten()); <span class="comment">//=&gt;[ 2, 3, 2, 2, 3, 'f', 'w', 3, &#123; name: 'Tom' &#125; ]</span></div></pre></td></tr></table></figure>
<p>这是通过递归的方法实现了多维数组的降维，在这里面，我有使用了原型链将方法封装进了Array原型中，可以直接在数组方法中调用。</p>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.deepFlatten = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = []; <span class="comment">//定义保存结果的数组</span></div><div class="line">    <span class="keyword">var</span> stack = <span class="keyword">this</span>; <span class="comment">//将数组放入栈中</span></div><div class="line">    <span class="keyword">while</span> (stack.length !== <span class="number">0</span>) &#123; <span class="comment">//如果栈不为空，则循环遍历</span></div><div class="line">        <span class="keyword">var</span> val = stack.pop(); <span class="comment">//取出最后一个值</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val)) &#123; <span class="comment">//判断是不是数组</span></div><div class="line">            stack = stack.concat(val); <span class="comment">//如果是数组就将拼接入栈中</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.unshift(val); <span class="comment">//如果不是数组就将其取出来放入结果数组中</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">2</span>, <span class="number">2</span>],</div><div class="line">    [<span class="number">3</span>, <span class="string">'f'</span>, [<span class="string">'w'</span>, <span class="number">3</span>]], &#123; <span class="string">"name"</span>: <span class="string">'Tom'</span> &#125;</div><div class="line">];</div><div class="line"><span class="built_in">console</span>.log(arr.deepFlatten()); <span class="comment">//=&gt;[ 2, 3, 2, 2, 3, 'f', 'w', 3, &#123; name: 'Tom' &#125; ]</span></div></pre></td></tr></table></figure>
<p>这是通过栈方法，建立了一个栈，将数组的内容存进去，然后逐个取出来，如果取出来的是个数组，就将这个数组打散拼接进栈中，在出栈一个，这样循环。</p>
<p>多维数组降维的方法也可以降维二维数组，但是有点大材小用，还是用对的方法做对的事才是最好的！</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端面试宝典之HTML/CSS]]></title>
      <url>http://www.foreverz.cn/2016/10/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BHTML-CSS/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>前端内容太多太杂，要时时总结，这里就总结一下最近遇到的或者看到的前端面试题与HTML/CSS相关的题目，以便以后查阅，也与大家分享！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="对WEB标准以及W3C的理解与认识"><a href="#对WEB标准以及W3C的理解与认识" class="headerlink" title="对WEB标准以及W3C的理解与认识?"></a>对WEB标准以及W3C的理解与认识?</h3><p>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；</p>
<h3 id="xhtml和html有什么区别"><a href="#xhtml和html有什么区别" class="headerlink" title="xhtml和html有什么区别?"></a>xhtml和html有什么区别?</h3><p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言<br>最主要的不同：<br>    XHTML元素必须被正确地嵌套。<br>    XHTML元素必须被关闭。<br>    标签名必须用小写字母。<br>    XHTML文档必须拥有根元素。</p>
<h3 id="Doctype的作用-什么是严格模式与混杂模式-如何触发这两种模式，区分它们有何意义"><a href="#Doctype的作用-什么是严格模式与混杂模式-如何触发这两种模式，区分它们有何意义" class="headerlink" title="Doctype的作用?什么是严格模式与混杂模式,如何触发这两种模式，区分它们有何意义?"></a>Doctype的作用?什么是严格模式与混杂模式,如何触发这两种模式，区分它们有何意义?</h3><p><code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于<code>&lt;html&gt;</code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。<br>严格模式：使用此类型的网页，浏览器解析将相对严格，不允许使用任何表现样式的标识和属性，比如在元素中直接使用background-color背景色属性。<br>混杂模式：浏览器对XHTML的解析较为宽松。允许使用4.01中的标签，但必须符合XHTML的语法。</p>
<h3 id="什么是语义化的HTML"><a href="#什么是语义化的HTML" class="headerlink" title="什么是语义化的HTML?"></a>什么是语义化的HTML?</h3><p>HTML 标签语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用；<br>对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，网站的推广便可以省下不少的功夫。<br>语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。</p>
<h3 id="行内元素有哪些？块级元素有哪些？空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？空(void)元素有那些？</h3><p>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea;<br>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote;<br>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img;</p>
<h3 id="标签上alt与title属性的区别是什么"><a href="#标签上alt与title属性的区别是什么" class="headerlink" title="标签上alt与title属性的区别是什么?"></a>标签上alt与title属性的区别是什么?</h3><p><code>Alt</code>当图片不显示时用文字代表。<br><code>Title</code>为该属性提供信息，当鼠标移动上去时显示。</p>
<h3 id="前端页面有哪三层构成，分别是什么-作用是什么"><a href="#前端页面有哪三层构成，分别是什么-作用是什么" class="headerlink" title="前端页面有哪三层构成，分别是什么?作用是什么?"></a>前端页面有哪三层构成，分别是什么?作用是什么?</h3><p>结构层；主要指DOM节点；HTML/XHTML;<br>样式层；主要是指页面渲染；CSS;<br>脚本层：主要指页面动画效果；JS/AS;</p>
<h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h3 id="CSS引入的方式有哪些-link和-import的区别是"><a href="#CSS引入的方式有哪些-link和-import的区别是" class="headerlink" title="CSS引入的方式有哪些? link和@import的区别是?"></a>CSS引入的方式有哪些? link和@import的区别是?</h3><p>CSS引入的方式有内联、内嵌、外链、导入四种。<br>link属于XHTML标签，而@import是CSS提供的;<br>link标签除了可以加载CSS外，还可以做很多其它的事情，@import就只能加载CSS了。<br>import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;<br>内联和important中，important优先级高;<br><strong>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</strong>;</p>
<h3 id="什么是盒子模型？W3C与IE的盒子模型有什么区别？"><a href="#什么是盒子模型？W3C与IE的盒子模型有什么区别？" class="headerlink" title="什么是盒子模型？W3C与IE的盒子模型有什么区别？"></a>什么是盒子模型？W3C与IE的盒子模型有什么区别？</h3><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding和实际内容content。<br>根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。<br>IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。<br>解决：不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。<br>IE8 及更早IE版本不支持 填充的宽度和边框的宽度属性。<br>解决IE8及更早版本不兼容问题可以在HTML页面声明 即可。</p>
<h3 id="CSS选择符有哪些-哪些属性可以继承-优先级算法如何计算"><a href="#CSS选择符有哪些-哪些属性可以继承-优先级算法如何计算" class="headerlink" title="CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?"></a>CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?</h3><p>CSS选择符: 类选择器、 标签名选择器、 ID选择器、 后代选择器（派生选择器）、 群组选择器;<br>可以继承： 类选择器、 标签名选择器、 后代选择器（派生选择器）、群组选择器;<br>优先级算法：标签内直接定义：1000;ID选择器：100;类选择器 ：10;标签名选择器：1;</p>
<h3 id="css的基本语句构成"><a href="#css的基本语句构成" class="headerlink" title="css的基本语句构成?"></a>css的基本语句构成?</h3><p>选择器{属性1:值1;属性2:值2;……}</p>
<h3 id="你做的页面在哪些流览器测试过-这些浏览器的内核分别是什么"><a href="#你做的页面在哪些流览器测试过-这些浏览器的内核分别是什么" class="headerlink" title="你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?"></a>你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</h3><p>Ie(Trident)、火狐（Gecko）、谷歌（webkit/Blink）、opear(Presto)、Safari（webkit）</p>
<h3 id="什么是CSS-Hack"><a href="#什么是CSS-Hack" class="headerlink" title="什么是CSS Hack?"></a>什么是CSS Hack?</h3><p>一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。</p>
<p>IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 1、条件Hack</div><div class="line">&lt;!--[if IE]&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">		.test&#123;color:red;&#125;</div><div class="line">  &lt;/style&gt;</div><div class="line">&lt;![endif]--&gt;</div><div class="line">// 2、属性Hack</div><div class="line">.test&#123;</div><div class="line">color:#090\9; /* For IE8+ */</div><div class="line">*color:#f00;  /* For IE7 and earlier */</div><div class="line">_color:#ff0;  /* For IE6 and earlier */</div><div class="line">&#125;</div><div class="line">// 3、选择符Hack</div><div class="line">* html .test&#123;color:#090;&#125;       /* For IE6 and earlier */</div><div class="line">* + html .test&#123;color:#ff0;&#125;     /* For IE7 */</div></pre></td></tr></table></figure>
<h3 id="IE6-BUG的解决方法"><a href="#IE6-BUG的解决方法" class="headerlink" title="IE6 BUG的解决方法"></a>IE6 BUG的解决方法</h3><ol>
<li>双边距BUG:float引起的,使用display;</li>
<li>3像素问题:使用float引起的,使用dislpay:inline -3px;</li>
<li>超链接hover点击后失效:使用正确的书写顺序:link、visited、hover、active;</li>
<li>Ie的z-index问题:给父级添加position:relative;</li>
<li>Png透明:使用js代码改;</li>
<li>Min-height最小高度:!Important解决;</li>
<li>select在ie6下遮盖:使用iframe嵌套;</li>
<li>为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden;zoom:.08;line-height:1px）;</li>
</ol>
<h2 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h2><h3 id="CSS清除浮动"><a href="#CSS清除浮动" class="headerlink" title="CSS清除浮动"></a>CSS清除浮动</h3><p>应用在父级元素是自动获取高度的情况下，或者下面元素不需要浮动。</p>
<ol>
<li><p>结尾处加空<code>div</code>标签<code>clear</code>;<br><code>clear:both</code>:清除当前元素的左右浮动；<br><code>clear:left</code>:清除当前元素的左浮动；<br><code>clear:right</code>:清除当前元素的右浮动；<br>优点：简单，代码少，浏览器支持好；<br>缺点：如果页面浮动过多，就要增加很多空div</p>
</li>
<li><p>父级元素定义<code>height</code>;<br>解决了父级元素无法自动获得高度的问题；<br>优点：简单、代码少；<br>缺点：只适合固定高度的布局，，要给出精确的高度，如果高度小于父级元素的高度，会把下面内容覆盖；</p>
</li>
<li><p>父级div定义伪类:<code>after</code>和<code>zoom</code>;<br>父元素<code>div</code>：<code>zoom: 1</code>;<br>父元素div:after:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">	<span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">	<span class="attribute">display</span>: block;</div><div class="line">	<span class="attribute">clear</span>: both;</div><div class="line">	<span class="attribute">visibility</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>父级元素定义：<code>overflow:hidden</code>或<code>overflow:auto</code>;<br>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度;<br>优点：简单、代码少、浏览器支持好;<br>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 </p>
</li>
<li><p>父级div 也一起浮动;<br>原理：所有代码一起浮动，就变成了一个整体<br>缺点：会产生新的浮动问题。 </p>
</li>
<li><p>父级div定义:display:table;<br>原理：将div属性变成表格<br>缺点：会产生新的未知问题。 </p>
</li>
<li><p>结尾处加br标签，定义属性：<code>clear:both</code>;</p>
</li>
</ol>
<h3 id="浮动增加宽度会浮动滑移怎么办"><a href="#浮动增加宽度会浮动滑移怎么办" class="headerlink" title="浮动增加宽度会浮动滑移怎么办?"></a>浮动增加宽度会浮动滑移怎么办?</h3><ul>
<li>从设定的元素宽度中减去添加的水平外边距、边框和内边距的宽度和。</li>
<li>在容器内部的元素上添加内边距或外边距。</li>
<li>使用 CSS3 的 box-sizing 属性切换盒子缩放方式。应该该属性后，给元素添加边框和内边距都不会增大盒子，相反会导致内容变窄。</li>
</ul>
<h3 id="css三列布局"><a href="#css三列布局" class="headerlink" title="css三列布局"></a>css三列布局</h3><ul>
<li>左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏不设宽度，用左右<code>margin</code>值撑开距离</li>
<li>父元素：<code>display:box</code>;子元素：<code>box-flex: x</code>;总宽度为所有子元素的<code>box-flex</code>之和。</li>
<li>父元素：<code>display:table</code>;子元素：<code>display:table-cell</code>;表格布局，宽度自适应。但是会有等高问题。</li>
</ul>
<h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><ol>
<li><p>单行垂直居中<br>设置实际高度height和line-height</p>
</li>
<li><p>多行未知高度文字垂直居中<br>设置<code>padding</code></p>
</li>
<li><p>多行文本固定高度居中</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">	<span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid;</div><div class="line">	<span class="attribute">vertical-align</span>: middle;</div><div class="line">	<span class="attribute">display</span>: table-cell;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="定高div垂直居中"><a href="#定高div垂直居中" class="headerlink" title="定高div垂直居中"></a>定高div垂直居中</h3><ol>
<li><p>定位<br>先父元素：<code>position: relative</code>;<br>然后居中元素:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">	<span class="attribute">position</span>: absolute;</div><div class="line">	<span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">	<span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">	<span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">	<span class="attribute">margin-left</span>: -<span class="number">100px</span>;</div><div class="line">	<span class="attribute">margin-top</span>: -<span class="number">100px</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>flex<br>父元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</div><div class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;</div><div class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端如何跨域]]></title>
      <url>http://www.foreverz.cn/2016/10/20/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>在JavaScript中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。然而，当进行一些比较深入的前端编程的时候，不可避免地需要进行跨域操作，这时候“同源策略”就显得过于苛刻。这时候就需要跨域！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<h3 id="为什么要有同源限制"><a href="#为什么要有同源限制" class="headerlink" title="为什么要有同源限制"></a>为什么要有同源限制</h3><p>我们举例说明：比如一个黑客程序，他利用IFrame把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。而同源策略就为了防止这种事情发生。<br>比如说，浏览器的两个tab页中分别打开了<a href="http://www.baidu.com/index.html和http" target="_blank" rel="external">http://www.baidu.com/index.html和http</a>: //www.google.com/index.html，其中，JavaScript1和JavaScript3是属于百度的脚本，而 JavaScript2是属于谷歌的脚本，当浏览器的tab1要运行一个脚本时，便会进行同源检查，只有和www.baidu.com同源的脚本才能被执行，所谓同源，就是指域名、协议、端口相同。所以，tab1只能执行JavaScript1和JavaScript3脚本，而JavaScript2不能 执行，从而防止其他网页对本网页的非法篡改。<br>如果两个页面拥有相同的协议（protocol），端口（如果指定），和主机，那么这两个页面就属于同一个源（origin）。</p>
<p>下图说明了同源策略的检测机制：</p>
<div style="text-align: center"><br><img src="http://oef1ordmv.bkt.clouddn.com/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.png" alt=""><br></div>

<h2 id="跨域网络访问"><a href="#跨域网络访问" class="headerlink" title="跨域网络访问"></a>跨域网络访问</h2><p>同源策略控制了不同源之间的交互，例如在使用<code>XMLHttpRequest</code>或标签时则会受到同源策略的约束。交互通常分为三类：</p>
<blockquote>
<p>浏览器同源策略并不是对所有的请求均制约：</p>
<blockquote>
<p>制约： XmlHttpRequest<br>不制约： img、iframe、script等具有src属性的标签</p>
</blockquote>
<p>处理Ajax跨域问题主要有以下4种方式：</p>
<blockquote>
<ol>
<li>利用JSONP</li>
<li>利用iframe</li>
<li>利用代理</li>
<li>跨域资源共享(CORS)</li>
</ol>
</blockquote>
</blockquote>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>在<code>HTML DOM</code>中,<code>script</code>标签是可以跨域访问服务器上的数据的.因此,可以指定<code>script</code>的<code>src</code>属性为跨域的<code>url</code>,从而实现跨域访问。<br>利用在页面中创建<code>&lt;script&gt;</code>节点的方法向不同域提交<code>HTTP</code>请求的方法称为<code>JSONP</code>，这项技术可以解决跨域提交<code>Ajax</code>请求的问题。</p>
<h4 id="客户端代码："><a href="#客户端代码：" class="headerlink" title="客户端代码："></a>客户端代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function doResponse(data)&#123;</div><div class="line">       console.log(&apos;开始处理响应数据&apos;);</div><div class="line">       console.log(data);</div><div class="line">&#125;</div><div class="line">//JSONP方式</div><div class="line">$(&apos;#bt3&apos;).click(function()&#123;</div><div class="line">       var script = document.createElement(&apos;script&apos;);</div><div class="line">	   script.type = &quot;text/javascript&quot;;</div><div class="line">       script.src=&quot;http://localhost/AJAX_day08/5.php?callback=doResponse&quot;;</div><div class="line">       document.head.appendChild(script);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="服务器端代码："><a href="#服务器端代码：" class="headerlink" title="服务器端代码："></a>服务器端代码：</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">'Content-Type: application/javascript'</span>);</div><div class="line">$cb = $_REQUEST[<span class="string">'callback'</span>];</div><div class="line">$arr = [<span class="string">'ename'</span>=&gt;<span class="string">'King'</span>, <span class="string">'age'</span>=&gt;<span class="number">50</span>];</div><div class="line">$str = json_encode($arr);</div><div class="line"><span class="keyword">echo</span> $cb.<span class="string">'('</span> .$str. <span class="string">')'</span> ;</div></pre></td></tr></table></figure>
<h4 id="jQuery中两个可以发起JSONP请求的函数"><a href="#jQuery中两个可以发起JSONP请求的函数" class="headerlink" title="jQuery中两个可以发起JSONP请求的函数"></a>jQuery中两个可以发起JSONP请求的函数</h4><blockquote>
<p>$.getJSON()</p>
<blockquote>
<p>XHR请求：<code>$.getJSON(&#39;x.php&#39;, data, fn);</code><br>JSONP请求：<code>$.getJSON(&#39;x.php?callback=?&#39;,data,fn);</code></p>
</blockquote>
<p>$.ajax();</p>
<blockquote>
<p>XHR请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">        url: &apos;x.php&apos;,</div><div class="line">        data: &#123;&apos;uname&apos;:&apos;tom&apos;&#125;,</div><div class="line">        success: fn</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>JSONP请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">        url: &apos;x.php&apos;,</div><div class="line">        data: &#123;&apos;uname&apos;:&apos;tom&apos;&#125;,</div><div class="line">        dataType: &apos;jsonp&apos;,  /*text/html/script/xml/json/jsonp指定服务器端返回的数据的类型*/</div><div class="line">        success: fn</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<ul>
<li>JSONP的优点<br>不像<code>XMLHttpRequest</code>对象实现的<code>Ajax</code>请求那样受到同源策略的限制；兼容性更好，在更加古老的浏览器中都可以运行，不需要<code>XMLHttpRequest</code>或<code>ActiveX</code>的支持；并且在请求完毕后可以通过调用<code>callback</code>的方式回传结果。</li>
<li>JSONP的缺点<br>只支持<code>GET</code>请求而不支持<code>POST</code>等其它类型的<code>HTTP</code>请求；它只支持跨域<code>HTTP</code>请求这种情况，不能解决不同域的两个页面之间如何进行<code>JavaScript</code>调用的问题。</li>
</ul>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>一般分两种情况：</p>
<h4 id="是同主域下面，不同子域之间的跨域"><a href="#是同主域下面，不同子域之间的跨域" class="headerlink" title="是同主域下面，不同子域之间的跨域"></a>是同主域下面，不同子域之间的跨域</h4><p>同主域，不同子域跨域，设置相同的document.domian就可以解决;<br>父页访问子页，可以document.getElementById(“myframe”).contentWindow.document来访问iframe页面的内容；如果支持contentDocument也可以直接document.getElementById(“myframe”).contentDocument访问子页面内容；<br>子页访问父页，可以parent.js全局属性;</p>
<h4 id="不同主域跨域"><a href="#不同主域跨域" class="headerlink" title="不同主域跨域"></a>不同主域跨域</h4><p>前提，<code>www.a.com</code>下<code>a.html</code>，<code>a.html</code>内<code>iframe</code>调用了<code>www.b.com</code>下的<code>b.html</code>，<code>b.html</code>下<code>iframe</code>调用了<code>www.a.com</code>下的<code>c.html</code>;<br><code>b.html</code>是不无法直接访问<code>a.html</code>的对象，因为涉及到跨域，但可以访问<code>parent</code>，同样<code>c.html</code>的<code>parent</code>可以访问<code>b.html</code>。<code>c.html</code>和<code>a.html</code>同域，是可以访问<code>a</code>下的对象的。<code>parent.parent.js</code>对象!</p>
<h3 id="利用代理"><a href="#利用代理" class="headerlink" title="利用代理"></a>利用代理</h3><p>即用户访问A网站时所产生的对B网站的跨域访问请求均提交到A网站的指定页面（Post页面过去），由该页面代替用户页面完成交互，从而返回合适的结果。此方案可以解决现阶段所能够想到的多数跨域访问问题，但要求A网站提供Web代理的支持，因此A网站与B网站之间必须是紧密协作的，且每次交互过程，A网站的服务器负担增加，且无法代用户保存session状态。</p>
<h3 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享(CORS)"></a>跨域资源共享(CORS)</h3><p>新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做”跨域资源共享”（Cross-origin resource sharing，简称CORS）。<br>使用”跨域资源共享”的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种”跨域”。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。</p>
<p>服务器端则要进行一些设置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">'Access-Control-Allow-Origin:*'</span>); </div><div class="line">header(<span class="string">'Access-Control-Allow-Methods:POST,GET'</span>);</div></pre></td></tr></table></figure></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是前端实现跨域的几种方式，很多时候我们都会遇到跨域的问题，以上几种方法就可以解决了，因此要好好掌握。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从输入URL到页面加载完成的过程中都发生了什么事情？]]></title>
      <url>http://www.foreverz.cn/2016/10/20/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>前端不仅要让用户对网页有完美的体验，让用户尽快体验到完美的网页也是很重要的，这就要前端攻城狮掌握一些计算机原理相关的知识了，这里就来聊一聊从用户输入URL到页面加载完成的过程中都发生了什么事情？<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<blockquote>
<p>用户输入url之后大致发生了以下几件事：</p>
<blockquote>
<ol>
<li>浏览器查找域名的IP地址:这一步包括DNS具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…</li>
<li>浏览器向web服务器发送一个HTTP请求;</li>
<li>服务器的永久重定向响应;</li>
<li>浏览器跟踪重定向地址;</li>
<li>服务器处理请求;</li>
<li>服务器返回一个HTTP响应;</li>
<li>浏览器显示HTML;</li>
<li>浏览器发送请求获取嵌入在HTML中的资源（如图片、音频、视频、CSS、JS等等）;</li>
<li>浏览器发送异步请求;</li>
</ol>
</blockquote>
</blockquote>
<p>下面我们就详细地了解一下这些过程。</p>
<h2 id="DNS查找IP地址"><a href="#DNS查找IP地址" class="headerlink" title="DNS查找IP地址"></a>DNS查找IP地址</h2><p>DNS是域名系统(Domain Name System)的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<h3 id="DNS查找过程"><a href="#DNS查找过程" class="headerlink" title="DNS查找过程"></a>DNS查找过程</h3><ol>
<li>浏览器缓存 – 浏览器会缓存DNS记录一段时间，但是操作系统并没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。</li>
<li>系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。</li>
<li>路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。</li>
<li>ISP DNS缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</li>
<li>递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从.com顶级域名服务器到example的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。</li>
</ol>
<h3 id="DNS进行域名解析的过程"><a href="#DNS进行域名解析的过程" class="headerlink" title="DNS进行域名解析的过程"></a>DNS进行域名解析的过程</h3><ol>
<li>客户端发出DNS请求翻译IP地址或主机名；</li>
<li>DNS服务器在收到客户机的请求后检查DNS服务器的缓存，若查到请求的地址或名字，即向客户机发出应答信息；</li>
<li>若没有查到，则在数据库中查找，若查到请求的地址或名字，即向客户机发出应答信息；</li>
<li>若没有查到，则将请求发给根域DNS服务器，并依序从根域查找顶级域，由顶级查找二级域，二级域查找三级，直至找到要解析的地址或名字，即向客户机所在网络的DNS服务器发出应答信息，DNS服务器收到应答后现在缓存中存储，然后，将解析结果发给客户机。</li>
<li>若没有找到，则返回错误信息。</li>
</ol>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h3 id="三次握手建立TCP连接"><a href="#三次握手建立TCP连接" class="headerlink" title="三次握手建立TCP连接"></a>三次握手建立TCP连接</h3><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<ul>
<li>第一次握手：<br>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；<br>SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：<br>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：<br>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据。<br>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。<br>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>
<h3 id="四次挥手终止连接"><a href="#四次挥手终止连接" class="headerlink" title="四次挥手终止连接"></a>四次挥手终止连接</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li>
<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器关闭客户端的连接，发送一个FIN给客户端。</li>
<li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ol>
<h2 id="服务器的永久重定向响应"><a href="#服务器的永久重定向响应" class="headerlink" title="服务器的永久重定向响应"></a>服务器的永久重定向响应</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“HTTP://www.facebook.com/” 而非“HTTP://facebook.com/”。<br>为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？这个问题有好多有意思的答案。<br>其中一个原因跟搜索引擎排名有关。你看，如果一个页面有两个地址，就像HTTP://www.igoro.com/ 和HTTP://igoro.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是 什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。<br>还有一个是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>
<h2 id="浏览器跟踪重定向地址"><a href="#浏览器跟踪重定向地址" class="headerlink" title="浏览器跟踪重定向地址"></a>浏览器跟踪重定向地址</h2><p>现在，浏览器知道了“HTTP://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求。</p>
<h2 id="服务器”处理”请求"><a href="#服务器”处理”请求" class="headerlink" title="服务器”处理”请求"></a>服务器”处理”请求</h2><p>服务器接收到获取请求，然后处理并返回一个响应。</p>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>现代浏览器渲染页面的过程是这样的：解析<code>HTML</code>以构建<code>DOM树</code> –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。</p>
<p><code>DOM树</code>是由<code>HTML</code>文件中的标签排列组成，渲染树是在<code>DOM树</code>中加入<code>CSS</code>或<code>HTML</code>中的<code>style</code>样式而形成。渲染树只包含需要显示在页面中的<code>DOM元素</code>，像<code>&lt;head&gt;</code>元素或<code>display</code>属性值为<code>none</code>的元素都不在渲染树中。<br>在浏览器还没接收到完整的<code>HTML</code>文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送<code>HTTP</code>请求重复上述的步骤。在收到<code>CSS</code>文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>做前端不仅要掌握前端的知识，对一些前端相关的例如计算机网络、数据结构、计算机原理都要有一定的了解，因为网络世界连接在一起的，前端与这些知识都是有接触的，说不准什么时候就会用上。而且，学好这些知识，对前端优化也有很大的帮助。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js的原型与继承]]></title>
      <url>http://www.foreverz.cn/2016/10/20/js%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>js是可以面向对象编程的，而面向对象很重要的一个特性就是继承，js的继承是通过原型链模拟的，达到了继承的效果，我们就探讨一下原型链和继承到底是什么。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>继承是指一个对象直接使用另一个对象的属性和方法，是面向对象语言中类与类之间的一种关系。继承的类被称为子类、派生类，就是在JS中所说的实例化的对象；而被继承的类被称为父类、基类或超类，在JS中一般是构造函数。</p>
<h2 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h2><p>通过继承，可以使得子类拥有父类的属性和方法，同时子类也可以通过加入新的属性和方法或者修改父类的属性和方法建立新的类层次。<br>继承体制体现了面向对象技术中的复用性、扩展性和安全性。为面向对象软件开发和模块化软件架构提供了最基本的技术基础。</p>
<h2 id="JS中的类"><a href="#JS中的类" class="headerlink" title="JS中的类"></a>JS中的类</h2><p>JS本身就是一种面向对象的语言，它所涉及的元素根据其属性的不同都依附于某一个特定的类。<br>我们常见的类包括：对象变量(Object)、结构变量(Function)、数组变量(Array)、字符串变量(String)、数值变量(Number)、逻辑变量(Boolean)、日期变量(Data)等，而相关的类的方法，也是我们经常用到的，例如数组的push方法，字符串的split方法等。但是在实际编程中这些方法严重不足，所以也就有了<code>prototype</code>。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在JS中，每个对象都会在其内部初始化一个属性，就是<code>__proto__</code>，当我们访问一个对象的属性时，如果这个对象的内部不存在这个属性，那么它就会去<strong>proto</strong>里寻找这个属性，这个<strong>proto</strong>又会有自己的<strong>proto</strong>，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>
<p><code>__proto__</code>是原型链中对象之间从下到上的联系的桥梁，所有的对象的<strong>proto</strong>最终都指向<code>Object.prototype</code>，为<code>undefined</code>。</p>
<p>按照标准，<strong>proto</strong>是不对外公开的，也就是说这是个私有属性，但是现在很多浏览器引擎已经将它暴露出来称为一个公有属性，可以对外访问和设置。</p>
<p>但是大多是时候我们并不需要使用<strong>proto</strong>，而是使用prototype来向下继承。JS每个函数都是一个Function对象，函数对象都有一个子对象prototype对象。而JS中的类是以函数的形式来定义的。prototype表示该函数的原型，也表示一个类的成员的集合。在通过<code>new</code>创建一个类的实例对象时，prototype对象的成员都成为实例化对象的成员，可以被对象直接使用。</p>
<p>其实，prototype只是一个假象，在原型链中只起到一个辅助作用，只有在对构造函数<code>new</code>实例化时才会用有一定的价值，原型链的本质其实在于<code>__proto__</code>。</p>
<p>下面看一个简单的例子来详细理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.width = <span class="number">10</span>;</div><div class="line">    <span class="keyword">this</span>.data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    <span class="keyword">this</span>.key = <span class="string">"this is A"</span>;</div><div class="line">&#125;</div><div class="line">A._objectNum = <span class="number">0</span>; <span class="comment">//定义A的属性</span></div><div class="line">A.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//给A的原型对象添加属性</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>图解过程如下：</p>
<div style="text-align: center"><br><img src="http://oef1ordmv.bkt.clouddn.com/prototypes-and-inheritance2.jpg" alt=""><br></div>

<p>简单说原型就是函数的一个属性，在函数的创建过程中由JS编译器自动添加。</p>
<h2 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h2><p>在上面的例子中，A函数是一个构造函数，可以用<code>new</code>来实例化；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> A;</div><div class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> A;</div></pre></td></tr></table></figure></p>
<p>这是通过构造函数来创建对象的方式，那么创建对象为什么要这样创建而不是直接var a1 = {};呢？这就涉及new的具体步骤了，这里的new操作可以分成三步(以a1的创建为例)：</p>
<ol>
<li>新建一个对象并赋值给变量a1：<code>var a1 = {}</code>;</li>
<li>把这个对象的<strong>proto</strong>属性指向函数A的原型对象：<code>a1.__proto__= A.prototype</code>;</li>
<li>调用函数A，同时把this指向创建的对象a1，对对象进行初始化：A.apply(a1,arguments);<br>其结构图示如下：</li>
</ol>
<div style="text-align: center"><br><img src="http://oef1ordmv.bkt.clouddn.com/prototypes-and-inheritance3.jpg" alt=""><br></div>

<p>从图中看到，无论是对象a1还是a2，都有一个属性保存了对函数A的原型对象的引用，对于这些对象来说，一些公用的方法可以在函数的原型中找到，节省了内存空间。</p>
<p>注意，在这里<code>new</code>实例化的<code>a1</code>、<code>a2</code>是Object对象，而不是函数方法。</p>
<h2 id="JS中的继承"><a href="#JS中的继承" class="headerlink" title="JS中的继承"></a>JS中的继承</h2><p>js里常用的如下两种继承方式：</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><h4 id="原型链继承原理"><a href="#原型链继承原理" class="headerlink" title="原型链继承原理"></a>原型链继承原理</h4><p>原型式继承是借助已有的对象创建新的对象，将子类的原型指向父类，就相当于加入了父类这条原型链。<br>例如定义一个空函数B:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>这个时候产生了B的原型<code>B.prototype</code>;<br>原型本身就是一个Object对象，我们可以看看里面放着哪些数据<br><code>B.prototype</code>实际上就是<code>{constructor : B , __proto__: Object.prototype}</code>,因为prototype本身是一个Object对象的实例，所以其原型链指向的是Object的原型。</p>
<p>接下来我们让B继承A：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B.prototype = <span class="keyword">new</span> A();</div></pre></td></tr></table></figure></p>
<p>这样产生的结果是：<br>产生一个A的实例，同时赋值给B的原型，也即<code>B.prototype</code>相当于对象<code>{width :10 , data : [1,2,3] , key : &quot;this is A&quot; ,__proto__: A.prototype}</code>;<br>这样就把A的原型通过<code>B.prototype.__proto__</code>这个对象属性保存起来，构成了原型的链接。<br>但是注意，这样B产生的对象的构造函数发生了改变，因为在B中没有<code>constructor</code>属性，只能从原型链找到<code>A.prototype</code>，读出<code>constructor:A</code>。<br>所以有时我们还要人为设回B本身：<code>B.prototype.constructor = B</code>;</p>
<h4 id="原型链直接继承"><a href="#原型链直接继承" class="headerlink" title="原型链直接继承"></a>原型链直接继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.say = <span class="string">'Hello'</span>;</div><div class="line">&#125;</div><div class="line">A.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.say); <span class="comment">//=&gt;Hello</span></div><div class="line">a.sayHello(); <span class="comment">//=&gt;Hello</span></div></pre></td></tr></table></figure>
<p>这样直接通过一个函数<code>new</code>实例化继承下来的就是直接继承了。会得到一个Object对象<code>a</code>，继承了构造函数<code>A</code>的属性和方法。</p>
<h4 id="原型链多重继承"><a href="#原型链多重继承" class="headerlink" title="原型链多重继承"></a>原型链多重继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.say += <span class="string">' World!'</span>;</div><div class="line">&#125;;</div><div class="line">B.prototype = <span class="keyword">new</span> A();</div><div class="line">B.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">b.sayHello(); <span class="comment">//=&gt;hello world!</span></div><div class="line">b.sayHi(); <span class="comment">//=&gt;Hi!</span></div></pre></td></tr></table></figure>
<p>在这里B继承里A的属性和方法，同时又声明了自己的属性和方法。然后通过<code>new</code>实例化，得到一个Object对象<code>b</code>，可以同时使用<code>A</code>和<code>B</code>的属性和方法。</p>
<p>通过这样我们就可以使用<code>prototype</code>实现继承，使用父类的属性和方法，实现代码的复用，大大减少代码量。</p>
<h3 id="类式继承（构造函数间的继承）"><a href="#类式继承（构造函数间的继承）" class="headerlink" title="类式继承（构造函数间的继承）"></a>类式继承（构造函数间的继承）</h3><h4 id="类式继承原理"><a href="#类式继承原理" class="headerlink" title="类式继承原理"></a>类式继承原理</h4><p>类式继承是在子类型构造函数的内部调用超类型的构造函数。严格的类式继承并不是很常见，一般都是组合着用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a + b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a - b);</div><div class="line">&#125;</div><div class="line">add.call(sub, <span class="number">3</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>这个例子中的意思就是用<code>add</code>来替换<code>sub</code>，<code>add.call(sub,3,1) == add(3,1)</code>，所以运行结果为：4;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"Animal"</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"Cat"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</div><div class="line">animal.showName.call(cat); <span class="comment">//=&gt;Cat</span></div></pre></td></tr></table></figure>
<p><code>call</code>的意思是把<code>animal</code>的方法放到<code>cat</code>上执行，原来<code>cat</code>是没有<code>showName()</code>方法，现在是把<code>animal</code>的<code>showName()</code>方法放到<code>cat</code>上来执行，所以<code>this.name</code>应该是<code>Cat</code>;</p>
<h4 id="类式直接继承"><a href="#类式直接继承" class="headerlink" title="类式直接继承"></a>类式直接继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    Animal.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"Black Cat"</span>);</div><div class="line">cat.showName(); <span class="comment">//=&gt;Black Cat</span></div></pre></td></tr></table></figure>
<p>Animal.call(this) 的意思就是使用Animal对象代替this对象，那么Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.</p>
<h4 id="类式多重继承"><a href="#类式多重继承" class="headerlink" title="类式多重继承"></a>类式多重继承</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.showSub = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a - b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.showAdd = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a + b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassC</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ClassA.call(<span class="keyword">this</span>);</div><div class="line">    ClassB.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ClassC();</div><div class="line">c.showSub(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">//=&gt;2</span></div><div class="line">c.showAdd(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">//=&gt;4</span></div></pre></td></tr></table></figure>
<p>很简单，使用两个 call 就实现多重继承了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JS的面向继承有很重要的作用，可以使得子类拥有父类的属性和方法，大大提高了代码的复用性、扩展性和安全性，但是JS中是用原型链模拟的继承，所以效率有些低下，代码量少的时候可以少用或不用继承。</p>
<p>参考链接：<br><a href="http://blog.jobbole.com/19795/" target="_blank" rel="external">JavaScript原型和继承</a><br><a href="https://segmentfault.com/a/1190000002440502" target="_blank" rel="external">JavaScript继承方式详解</a></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js函数与作用域链]]></title>
      <url>http://www.foreverz.cn/2016/10/19/js%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>js中有函数和作用域的概念，在js中变量和函数都依赖于作用域，作用域又是以作用域链的形式存在的。函数的定义和执行都与作用域链息息相关！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="函数的概念和作用"><a href="#函数的概念和作用" class="headerlink" title="函数的概念和作用"></a>函数的概念和作用</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块，是用来帮助我们封装、调用代码的最方便的工具！<br>在js中，函数是一种带有可执行代码的对象类型数据。JS中的函数其实是对象，函数名是对 Function 对象的引用。</p>
<h2 id="函数的创建方法"><a href="#函数的创建方法" class="headerlink" title="函数的创建方法"></a>函数的创建方法</h2><p>函数的创建方法有四种：</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;</div><div class="line">fun();</div></pre></td></tr></table></figure>
<p>在这种定义方式下，函数不属于任何对象，但是在js中它始终是默认的全局对象！函数必须用<code>fun()</code>来调用，也可以在函数声明前调用，但是不调用的函数是没有用的。</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;</div><div class="line">fun();</div></pre></td></tr></table></figure>
<p>这种方式是将函数保存在变量中，也是通过<code>fun()</code>调用，但是这里因为变量有声明提前，原地赋值的特性，所以不能提前调用，只能在定义之后再使用。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>匿名函数是没有函数名的一种函数，会直接执行，不能再函数外调用，但是可以在函数内通过<code>arguments.callee()</code>自调。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="built_in">console</span>.log(<span class="string">'Hello World'</span>));</div></pre></td></tr></table></figure>
<p>这种方法是比较少见的一种函数创建方法，也是很神奇的一种方法，这里简略一下，后面会详细说明。这种方法还有一个特点，就是函数可以自调。</p>
<h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><p>函数的调用方式有四种：</p>
<h3 id="作为一个函数去调用"><a href="#作为一个函数去调用" class="headerlink" title="作为一个函数去调用"></a>作为一个函数去调用</h3><p>调用方式就是前面用过的<code>fun();</code>,以函数名+()的方式直接调用，也是我们常见的调用方法。此时函数作为全局对象调用，会使this的值成为全局对象，使用window对象作为一个变量，容易造成程序崩溃！</p>
<h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><p>函数作为对象的方法调用，会使this的值成为对象的本身！举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">say</span>: <span class="string">'Hello World!'</span>,</div><div class="line">    <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.sayHello();</div></pre></td></tr></table></figure></p>
<h3 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.say = <span class="string">"Hello World!"</span>;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fun();</div><div class="line">obj.say;	<span class="comment">//=&gt;Hello World!</span></div><div class="line">obj.sayHello();</div></pre></td></tr></table></figure>
<p>构造函数中的this没有任何值，但是当用<code>new</code>新建<code>obj</code>对象时，this会指向<code>obj</code>，此时<code>obj</code>会继承<code>fun</code>的属相和方法成为自己的属性和方法！</p>
<h3 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><p>在js中函数是对象，是对象就有对象的方法，而<code>call()</code>和<code>apply()</code>是预定义的函数方法！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a * b);</div><div class="line">&#125;</div><div class="line">fun.call(foo, <span class="number">10</span>, <span class="number">2</span>);	<span class="comment">//=&gt;20</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a * b);</div><div class="line">&#125;</div><div class="line">fun.apply(foo, [<span class="number">10</span>, <span class="number">2</span>]);	<span class="comment">//=&gt;20</span></div></pre></td></tr></table></figure>
<p><code>call</code>和<code>apply</code>是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。在这里<code>foo</code>只是一个变量，没有任何属性和方法，所以用call或apply调用<code>fun</code>方法操作。<br>两个方法的区别在于call传入的是一个个普通的参数，而apply传入的是一个数组。</p>
<h2 id="函数的运行机制"><a href="#函数的运行机制" class="headerlink" title="函数的运行机制"></a>函数的运行机制</h2><ol>
<li>在js中，js引擎会优先解析var变量和function定义！在预解析完成后从上到下逐步进行！</li>
<li>解析var变量时，会把值存储在“执行环境”中，而不会去赋值，也就是通常所说的声明提前，原地赋值。</li>
<li>而在解析function时会把函数整体定义，这也就解释了为什么在function定义函数时为什么可以先调用后声明了！其实表面上看是先调用了，其实在内部机制中第一步实行的是把以function方式定义的函数先声明了！</li>
<li>函数被调用时，是运行在被声明时的语法环境中。</li>
<li>函数自己无法运行，它总是被对象调用的，函数运行时，函数体内的this指向调用该函数的对象，如果调用函数时，没有明确的指定该对象，this默认指向window；</li>
</ol>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>1.在js中函数定义没有任何参数，调用该函数时可以传递任意参数！<br>2.arguments对象是数组对象。<br>3.arguments对象的length属性：获取函数的实参个数！<br>4.利用Arguments对象特性,实现模拟函数的重载的效果.</p>
<h2 id="JS作用域"><a href="#JS作用域" class="headerlink" title="JS作用域"></a>JS作用域</h2><h3 id="全局作用域（Global-Scope）"><a href="#全局作用域（Global-Scope）" class="headerlink" title="全局作用域（Global Scope）"></a>全局作用域（Global Scope）</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<ol>
<li>最外层函数和在最外层函数外面定义的变量拥有全局作用域；</li>
<li>所有未定义直接赋值的变量自动声明为拥有全局作用域；</li>
<li>所有window对象的属性拥有全局作用域；</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'hi!'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> b = <span class="string">'hello!'</span>;</div><div class="line">    c = <span class="string">'how are you!'</span>;</div><div class="line">    <span class="built_in">window</span>.d = <span class="string">'thank you!'</span>;</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//=&gt;hi!</span></div><div class="line">fun(); <span class="comment">//=&gt;hello!</span></div><div class="line"><span class="built_in">console</span>.log(d); <span class="comment">//=&gt;报错</span></div><div class="line"><span class="built_in">console</span>.log(c); <span class="comment">//=&gt;how are you!</span></div><div class="line"><span class="built_in">console</span>.log(d); <span class="comment">//=&gt;thank you!</span></div></pre></td></tr></table></figure>
<p>a,c,d都是全局变量，可以在任何地方直接使用,而b不是全局变量，只能声明它的函数内使用。</p>
<h3 id="局部作用域（Local-Scope）"><a href="#局部作用域（Local-Scope）" class="headerlink" title="局部作用域（Local Scope）"></a>局部作用域（Local Scope）</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。<br>在ES6中还引入了块级作用域，用<code>let</code>声明。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]],该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<ul>
<li>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = num1 + num2;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。<br>函数add的作用域将会在执行时用到。如执行以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>,<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。<br>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。如下图：</p>
<div style="text-align: center;"><br><img src="http://oef1ordmv.bkt.clouddn.com/AO.jpg" alt=""><br></div>

<p>在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>
<h3 id="作用域链的代码优化"><a href="#作用域链的代码优化" class="headerlink" title="作用域链的代码优化"></a>作用域链的代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。<br>如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。<br>一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p>
<h3 id="JS函数创建过程"><a href="#JS函数创建过程" class="headerlink" title="JS函数创建过程"></a>JS函数创建过程</h3><p>以一个空函数为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>当我们在代码里面声明这么一个空函数，js解析的本质是</p>
<ol>
<li>创建一个对象（有constructor属性及[[Prototype]]属性），根据ECMA，其中[[Prototype]]属性不可见、不可枚举;其实就是我们现在所见的<code>__proto__</code>属性，各大浏览器已经暴露出来。</li>
<li>创建一个函数（有name、prototype属性），再通过prototype属性引用刚才创建的对象;</li>
<li>创建变量A，同时把函数的引用赋值给变量A;<br>如下图所示：</li>
</ol>
<div style="text-align: center;"><br><img src="http://oef1ordmv.bkt.clouddn.com/prototypes-and-inheritance.jpg" alt=""><br></div>

<p><strong>每个函数的创建都经历上述过程。</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/Jabin/p/5804052.html" target="_blank" rel="external">Js函数的概念、作用、创建、调用！</a><br><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="external">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二叉树与JavaScript]]></title>
      <url>http://www.foreverz.cn/2016/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8EJavaScript/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>二叉树是非常基础有非常重要的数据结构，在一些场合有着非常重要的左右。掌握二叉树对编写高质量代码、减少代码量有很大的帮助！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="关于二叉树"><a href="#关于二叉树" class="headerlink" title="关于二叉树"></a>关于二叉树</h2><p>二叉树是一种特殊的树， 非常适合计算机处理数据， 所以对于程序员来说掌握二叉树是非常有必要的。</p>
<h3 id="二叉树是什么"><a href="#二叉树是什么" class="headerlink" title="二叉树是什么"></a>二叉树是什么</h3><p>二叉树是一种特殊的树，有以下两个特征：</p>
<ol>
<li>二叉树的每个结点的度都不大于2；</li>
<li>二叉树每个结点的孩子结点次序不能任意颠倒。</li>
</ol>
<h2 id="为什么使用二叉树"><a href="#为什么使用二叉树" class="headerlink" title="为什么使用二叉树"></a>为什么使用二叉树</h2><p>二叉树的前序遍历可以用来显示目录结构等；中序遍历可以实现表达式树，在编译器底层很有用；后序遍历可以用来实现计算目录内的文件及其信息等。<br>二叉树是非常重要的数据结构， 其中二叉树的遍历要使用到栈和队列还有递归等，很多其它数据结构也都是基于二叉树的基础演变而来的。熟练使用二叉树在很多时候可以提升程序的运行效率，减少代码量，使程序更易读。<br>二叉树不仅是一种数据结构，也是一种编程思想。学好二叉树是程序员进阶的一个必然进程。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树有深度遍历和广度遍历， 深度遍历有前序、 中序和后序三种遍历方法。 广度遍历就是层次遍历。 因为树的定义本身就是递归定义， 因此采用递归的方法实现树的三种遍历容易理解而且代码比较简洁。<br>有时对一段代码来说， 可读性有时比代码本身的效率要重要的多。</p>
<p>四种遍历的主要思想：</p>
<ol>
<li>前序遍历：访问根–&gt;遍历左子树–&gt;遍历右子树;</li>
<li>中序遍历：遍历左子树–&gt;访问根–&gt;遍历右子树;</li>
<li>后序遍历：遍历左子树–&gt;遍历右子树–&gt;访问根;</li>
<li>广度遍历：按照层次一层层遍历;</li>
</ol>
<p>例如<code>(a+b*c)-d/e</code>,该表达式用二叉树表示如图：</p>
<div style="text-align: center"><br><img src="http://oef1ordmv.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""><br></div>

<p>对该二叉树进行深度和广度遍历为：</p>
<p>前序遍历：- + a <em> b c / d e<br>中序遍历：a + b </em> c - d / e<br>后序遍历：a b c <em> + d e / -<br>广度遍历：- + / a </em> d e b c</p>
<h2 id="js中的二叉树"><a href="#js中的二叉树" class="headerlink" title="js中的二叉树"></a>js中的二叉树</h2><p>上述二叉树<code>(a+b*c)-d/e</code>在js中可以用对象的形式表示出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tree = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"-"</span>,</div><div class="line">    <span class="attr">left</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">'+'</span>,</div><div class="line">        <span class="attr">left</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'a'</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'*'</span>,</div><div class="line">            <span class="attr">left</span>: &#123;</div><div class="line">                <span class="attr">value</span>: <span class="string">'b'</span>,</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">right</span>: &#123;</div><div class="line">                <span class="attr">value</span>: <span class="string">'c'</span>,</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">right</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">'/'</span>,</div><div class="line">        <span class="attr">left</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'d'</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'e'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="js中二叉树的深度遍历"><a href="#js中二叉树的深度遍历" class="headerlink" title="js中二叉树的深度遍历"></a>js中二叉树的深度遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preListRec = []; <span class="comment">//定义保存先序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> preOrderRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        preListRec.push(node.value); <span class="comment">//将结点的值存入数组中</span></div><div class="line">        preOrderRec(node.left); <span class="comment">//递归遍历左子树</span></div><div class="line">        preOrderRec(node.right); <span class="comment">//递归遍历右子树</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">preOrderRec(tree);</div><div class="line"><span class="built_in">console</span>.log(preListRec);</div><div class="line"><span class="comment">//[ '-', '+', 'a', '*', 'b', 'c', '/', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<p>先序递归遍历的思路是先遍历根结点，将值存入数组，然后递归遍历：先左结点，将值存入数组，继续向下遍历，然后再回溯遍历右结点，将值存入数组，这样递归循环。</p>
<h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preListUnRec = []; <span class="comment">//定义保存先序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> preOrderUnRecursion = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> stack = [node]; <span class="comment">//将二叉树压入栈</span></div><div class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span>) &#123; <span class="comment">//如果栈为空，则循环遍历</span></div><div class="line">            node = stack.pop(); <span class="comment">//从栈中取出一个结点</span></div><div class="line">            preListUnRec.push(node.value); <span class="comment">//将取出结点的值存入数组中</span></div><div class="line">            <span class="keyword">if</span> (node.right) stack.push(node.right); <span class="comment">//如果存在右子树，将右子树压入栈</span></div><div class="line">            <span class="keyword">if</span> (node.left) stack.push(node.left); <span class="comment">//如果存在左子树，将左子树压入栈</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">preOrderUnRecursion(tree);</div><div class="line"><span class="built_in">console</span>.log(preListUnRec);</div><div class="line"><span class="comment">//[ '-', '+', 'a', '*', 'b', 'c', '/', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<p>先序非递归遍历是利用了栈，将根结点放入栈中，然后再取出来，将值放入结果数组，然后如果存在右子树，将右子树压入栈，如果存在左子树，将左子树压入栈，然后循环判断栈是否为空，重复上述步骤。</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inListRec = []; <span class="comment">//定义保存中序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> inOrderRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        inOrderRec(node.left); <span class="comment">//递归遍历左子树</span></div><div class="line">        inListRec.push(node.value); <span class="comment">//将结点的值存入数组中</span></div><div class="line">        inOrderRec(node.right); <span class="comment">//递归遍历右子树</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">inOrderRec(tree);</div><div class="line"><span class="built_in">console</span>.log(inListRec);</div><div class="line"><span class="comment">//[ 'a', '+', 'b', '*', 'c', '-', 'd', '/', 'e' ]</span></div></pre></td></tr></table></figure>
<p>中序递归遍历的思路是先递归遍历左子树，从最后一个左子树开始存入数组，然后回溯遍历双亲结点，再是右子树，这样递归循环。</p>
<h4 id="非递归遍历-1"><a href="#非递归遍历-1" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inListUnRec = []; <span class="comment">//定义保存中序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> inOrderUnRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> stack = []; <span class="comment">//建立一个栈</span></div><div class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span> || node) &#123; <span class="comment">//如果栈不为空或结点不为空，则循环遍历</span></div><div class="line">            <span class="keyword">if</span> (node) &#123; <span class="comment">//如果结点不为空</span></div><div class="line">                stack.push(node); <span class="comment">//将结点压入栈</span></div><div class="line">                node = node.left; <span class="comment">//将左子树作为当前结点</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//左子树为空，即没有左子树的情况</span></div><div class="line">                node = stack.pop(); <span class="comment">//将结点取出来</span></div><div class="line">                inListUnRec.push(node.value); <span class="comment">//将取出结点的值存入数组中</span></div><div class="line">                node = node.right; <span class="comment">//将右结点作为当前结点</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">inOrderUnRec(tree);</div><div class="line"><span class="built_in">console</span>.log(inListUnRec);</div><div class="line"><span class="comment">//[ 'a', '+', 'b', '*', 'c', '-', 'd', '/', 'e' ]</span></div></pre></td></tr></table></figure>
<p>非递归遍历的思路是将当前结点压入栈，然后将左子树当做当前结点，如果当前结点为空，将双亲结点取出来，将值保存进数组，然后将右子树当做当前结点，进行循环。</p>
<h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><h4 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> postListRec = []; <span class="comment">//定义保存后序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> postOrderRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        postOrderRec(node.left); <span class="comment">//递归遍历左子树</span></div><div class="line">        postOrderRec(node.right); <span class="comment">//递归遍历右子树</span></div><div class="line">        postListRec.push(node.value); <span class="comment">//将结点的值存入数组中</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">postOrderRec(tree);</div><div class="line"><span class="built_in">console</span>.log(postListRec);</div><div class="line"><span class="comment">//[ 'a', 'b', 'c', '*', '+', 'd', 'e', '/', '-' ]</span></div></pre></td></tr></table></figure>
<p>递归遍历也是和上面的差不多，先走左子树，当左子树没有孩子结点时，将此结点的值放入数组中，然后回溯遍历双亲结点的右结点，递归遍历。</p>
<h4 id="非递归遍历-2"><a href="#非递归遍历-2" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> postListUnRec = []; <span class="comment">//定义保存后序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> postOrderUnRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> stack = [node]; <span class="comment">//将二叉树压入栈</span></div><div class="line">        <span class="keyword">var</span> tmp = <span class="literal">null</span>; <span class="comment">//定义缓存变量</span></div><div class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span>) &#123; <span class="comment">//如果栈不为空，则循环遍历</span></div><div class="line">            tmp = stack[stack.length - <span class="number">1</span>]; <span class="comment">//将栈顶的值保存在tmp中</span></div><div class="line">            <span class="keyword">if</span> (tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) &#123; <span class="comment">//如果存在左子树</span></div><div class="line">                stack.push(tmp.left); <span class="comment">//将左子树结点压入栈</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp.right &amp;&amp; node !== tmp.right) &#123; <span class="comment">//如果结点存在右子树</span></div><div class="line">                stack.push(tmp.right); <span class="comment">//将右子树压入栈中</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                postListUnRec.push(stack.pop().value);</div><div class="line">                node = tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">postOrderUnRec(tree);</div><div class="line"><span class="built_in">console</span>.log(postListUnRec);</div><div class="line"><span class="comment">//[ 'a', 'b', 'c', '*', '+', 'd', 'e', '/', '-' ]</span></div></pre></td></tr></table></figure>
<p>这里使用了一个tmp变量来记录上一次出栈、入栈的结点。思路是先把根结点和左树推入栈，然后取出左树，再推入右树，取出，最后取根结点。</p>
<h2 id="js中二叉树的广度遍历"><a href="#js中二叉树的广度遍历" class="headerlink" title="js中二叉树的广度遍历"></a>js中二叉树的广度遍历</h2><p>广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。<br>实现原理：使用数组模拟队列，首先将根结点归入队列。当队列不为空时，执行循环：取出队列的一个结点，如果该节点有左子树，则将该节点的左子树存入队列；如果该节点有右子树，则将该节点的右子树存入队列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> breadthList = []; <span class="comment">//定义保存广度遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> breadthTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> que = [node]; <span class="comment">//将二叉树放入队列</span></div><div class="line">        <span class="keyword">while</span> (que.length !== <span class="number">0</span>) &#123; <span class="comment">//判断队列是否为空</span></div><div class="line">            node = que.shift(); <span class="comment">//从队列中取出一个结点</span></div><div class="line">            breadthList.push(node.value); <span class="comment">//将取出结点的值保存到数组</span></div><div class="line">            <span class="keyword">if</span> (node.left) que.push(node.left); <span class="comment">//如果存在左子树，将左子树放入队列</span></div><div class="line">            <span class="keyword">if</span> (node.right) que.push(node.right); <span class="comment">//如果存在右子树，将右子树放入队列</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">breadthTraversal(tree);</div><div class="line"><span class="built_in">console</span>.log(breadthList);</div><div class="line"><span class="comment">//[ '-', '+', '/', 'a', '*', 'd', 'e', 'b', 'c' ]</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树的遍历还是比较难懂的，如果想要好好的理解，可以把程序转化一下，比如递归的程序可以吧每个递归都写成实际的函数嵌套，这样一层层的直接执行代码，不用递归，就很容易读懂了。</p>
<p>参考资料：<a href="https://segmentfault.com/a/1190000004620352" target="_blank" rel="external">https://segmentfault.com/a/1190000004620352</a></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[详细理解JS闭包]]></title>
      <url>http://www.foreverz.cn/2016/10/16/%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3JS%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>最近参加面试，错过一个福利很好的公司，很是心痛。我发现很多大型公司都对校招生的项目要求不高，框架基本都没问，但是要求基础扎实，其中就有对闭包的考察，最近仔细钻研了一下，对闭包也有了一些理解，就在这总结一下。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>要了解闭包就要先了解js中的变量。<br>js中有全局变量和局部变量。其中可以在任意位置访问和修改的就是全局变量。在函数中用var声明的只能在函数内访问和修改的就是局部变量（let和var在函数中声明的变量作用是一样的，这里就不单列出来了）。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>局部变量必须用var关键字来声明，否则会自动添加到全局对象的属性上去，成为全局变量。</li>
<li>全局变量是一直存在的，你用或者不用，他就在那里。而局部变量只有在调用函数的时候才会存在，函数调用过后变量就会销毁，下一次使用函数的时候会重新创建。</li>
</ol>
<h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><ol>
<li>函数是可以进行多级嵌套的。</li>
<li>函数里面的子函数可以访问使用它上级定义的变量，不止是上一级，而是像冒泡一样逐层往上查找，找到了就会停止查找，而如果找到全局也没有找到就会报错。</li>
<li><p>函数里调用函数外变量不能用var，否则就是声明同名局部变量，对函数外变量不会有影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line">a();</div><div class="line"><span class="built_in">console</span>.log(x);</div></pre></td></tr></table></figure>
<p> 结果会先输出2，再输出1。这是因为在函数a里用<code>var</code>重新声明了一个局部变量x并赋值为2，此时在函数a中的变量x和全局变量x是没有关系的。所以调用函数a输出的是局部变量，结果为2，而最下面则输出的是全局变量，结果为1.</p>
</li>
<li><p>函数自调：函数除了上面用<code>a()</code>这样调用外，还可以自调，可以用()把函数包裹起来，后面跟上()执行这个函数。为什么包裹起来呢？因为不包裹那么就是对函数的声明，包裹起来就是一个表达式了，js会直接执行表达式，所以还可以在函数前加”~”、”+”、”-“等符号,函数后跟()让函数自调,但这些符号有很多局限，所以不是很了解的话还是少用。</p>
</li>
<li><p><strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong><br>其实这句话就是前面第三条，但是很重要，特别提出来，闭包的实现主要也是因为这个原因。</p>
</li>
<li><p>JavaScript中有回收机制，函数被引用执行完成后不再被引用，这个函数的作用域就会被回收销毁，如果两个对象互相引用，而不再被第三者所引用，那么这两个互相引用的对象也会被回收。但是两个对象互相引用，且在被第三者引用，那么就不会被回收。闭包的作用就是让这个函数的作用域不会被回收销毁。</p>
</li>
</ol>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包的解释：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>这是说的什么鬼，字都认识，可是合成一句话就一脸懵逼了，还是举个栗子吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        i ++;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = a();</div><div class="line">c(); <span class="comment">//=&gt; 1</span></div><div class="line">c(); <span class="comment">//=&gt; 2</span></div></pre></td></tr></table></figure></p>
<p>这段代码会输出1和2，我们会发现在这段代码中有两个特点：</p>
<pre><code>1. 函数b嵌套在函数a中;
2. 函数a返回函数b;
</code></pre><p>这就是一个最简单的闭包。<br>在执行完<code>var c = a()</code>之后，c其实是指向b的函数，那么<code>c();</code>就相当于在函数<code>a</code>外执行了<code>a</code>里的函数<code>b</code>。函数b被c引用，而c是全局变量，并不会被回收，而b是在a里面的函数，所以最后函数a的作用域就会被保存在内存中而不会被销毁。<br>所以如果把上面的代码修改一下，让全局变量c不引用b，就会释放a的作用域，闭包也就释放了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        i ++;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = a();</div><div class="line">c(); <span class="comment">//=&gt; 1</span></div><div class="line">c(); <span class="comment">//=&gt; 2</span></div><div class="line">c = a();</div><div class="line">c(); <span class="comment">//=&gt; 1</span></div><div class="line">c(); <span class="comment">//=&gt; 2</span></div></pre></td></tr></table></figure>
<p>上面代码在会输出两个1、2、1、2，而不是1、2、3、4，原因就是在第一个闭包形成输出1、2之后，将闭包释放了，然后又形成了一个新的闭包，调用又输出1和2。</p>
<p>还有一个更为常见的闭包写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        i++;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;)();</div><div class="line">a();</div><div class="line">a();</div></pre></td></tr></table></figure>
<p>匿名函数自执行把函数b赋给了a，这个a就是return回去的函数b；执行<code>a();</code>就是执行内函数b，这样就形成了一个闭包。</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>闭包是非常重要的一个概念，利用闭包很多的好处：</p>
<h3 id="保护函数内的变量安全-加强了封装性"><a href="#保护函数内的变量安全-加强了封装性" class="headerlink" title="保护函数内的变量安全,加强了封装性"></a>保护函数内的变量安全,加强了封装性</h3><p>以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。以第一个闭包来说，函数a中的i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。</p>
<h3 id="在内存中维持一个变量，使逻辑连续-用的太多就变成了缺点，占内存"><a href="#在内存中维持一个变量，使逻辑连续-用的太多就变成了缺点，占内存" class="headerlink" title="在内存中维持一个变量，使逻辑连续(用的太多就变成了缺点，占内存)"></a>在内存中维持一个变量，使逻辑连续(用的太多就变成了缺点，占内存)</h3><p>依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。</p>
<h3 id="实现JS私有属性和私有方法"><a href="#实现JS私有属性和私有方法" class="headerlink" title="实现JS私有属性和私有方法"></a>实现JS私有属性和私有方法</h3><p>通过保护函数内变量的安全，可以利用面向对象的方法创建函数的私有属性和私有方法，且不能被Constructor外访问到。</p>
<h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><p>闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;;</div><div class="line">    a(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子会创建10000个闭包，存在内存中不会释放，会造成内存的极大浪费，所以闭包要慎用。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="解决for循环后执行输出全为循环后值的问题。"><a href="#解决for循环后执行输出全为循环后值的问题。" class="headerlink" title="解决for循环后执行输出全为循环后值的问题。"></a>解决for循环后执行输出全为循环后值的问题。</h3><p>面试题，结果是什么？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个就是我之前遇到过的一个面试题，答案当然很简单，是3个4，不了解的童鞋可以去看一下定时器的运行机制。<br>那么怎么能让它输出1，2，3呢？<br>这个当然有很多的方法，我们这里用闭包来做。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;;</div><div class="line">    a(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个函数就是使用闭包实现了输出1,2,3；在这里a就是外包函数，setTimeout的回调函数就是内函数，而setTimeout就是在外部对内函数的调用。所以这里其实有3个闭包，每个闭包函数被调用了一次，然后就释放掉了。<br>这个函数还可以简化一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">    + <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是用了函数自调来实现的闭包，同样有3个闭包，那么怎么使用1个闭包来实现呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(a++);</div><div class="line">        &#125;, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>这里就是用了1个闭包实现了输出1,2,3；这里的a是内部变量，然后for循环和setTimeout是对内函数的3次外部调用。</p>
<h3 id="利用闭包模拟对象的私有属性"><a href="#利用闭包模拟对象的私有属性" class="headerlink" title="利用闭包模拟对象的私有属性"></a>利用闭包模拟对象的私有属性</h3><p>JavaScript以前缺少块级作用域，没有private修饰符，但是具有函数作用域。作用域的好处是内部函数可以访问它们的外部函数的参数和变量（除了this和argument。内部中的函数中的this指向全局对象，argument指向内部函数的函数参数）。我们可以利用这种属性来模拟面向对象中的私有属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">aname</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> aname = aname || <span class="string">'No Input'</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        get name() &#123;</div><div class="line">            <span class="keyword">return</span> aname;</div><div class="line">        &#125;,</div><div class="line">        set name(newNmae) &#123;</div><div class="line">            aname = newNmae;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fun = test();</div><div class="line"><span class="built_in">console</span>.log(fun.name);	<span class="comment">//=&gt;No Input</span></div><div class="line">fun.name = <span class="string">"mervyn"</span>;</div><div class="line"><span class="built_in">console</span>.log(fun.name);	<span class="comment">//=&gt;mervyn</span></div></pre></td></tr></table></figure></p>
<p>在这里利用闭包和访问器属性模拟出了对象的私有属性的读取与修改。</p>
<h3 id="利用闭包模拟对象的私有方法"><a href="#利用闭包模拟对象的私有方法" class="headerlink" title="利用闭包模拟对象的私有方法"></a>利用闭包模拟对象的私有方法</h3><p>模拟私有方法和模拟私有属相差不多，不过返回的直接是函数而不是访问器而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">aname</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> aname = aname || <span class="string">'No Input'</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> aname;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</div><div class="line">            aname = newName;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fun = test();</div><div class="line"><span class="built_in">console</span>.log(fun.getName());	<span class="comment">//=&gt;No Input</span></div><div class="line">fun.setName(<span class="string">'mervyn'</span>);</div><div class="line"><span class="built_in">console</span>.log(fun.getName());	<span class="comment">//=&gt;mervyn</span></div></pre></td></tr></table></figure></p>
<p>在这里利用闭包直接返回多个函数模拟出了对象的私有方法，可以再外部直接调用，像调用对象方法一样使用。</p>
<p>更多闭包的应用请参考<a href="http://www.cnblogs.com/star-studio/archive/2011/06/22/2086493.html" target="_blank" rel="external">这里</a>;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>闭包是一种非常强大的设计原则，在js中学会使用闭包是非常重要的，使用闭包可以大大简化用户的调用，达到目的。</li>
<li>不需要知道闭包的原理和细节，只要知道闭包的基本使用就可以了。</li>
<li>尽量少学习。</li>
</ol>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js的FileSystem文件模块]]></title>
      <url>http://www.foreverz.cn/2016/10/04/Node-js%E7%9A%84fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>FileSystem模块是类似UNIX（POSIX）标准的文件操作API，用于操作文件系统——读写目录、读写文件——Node.js底层使用C程序来实现，这些功能是客户端JS所不具备的。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>Nodejs导入文件系统模块(fs)语法如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>Node.js文件系统（fs模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。同步则没有回调函数。<br>建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.open(path,flags[,mode],[callback(err,data)]);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<ul>
<li>path - 文件的路径。</li>
<li>mode - 设置文件模式(权限)，文件创建默认权限为0666(可读，可写)。</li>
<li>callback - 回调函数，带有两个参数如：callback(err,fd)。</li>
<li>flags - 文件打开的行为。具体如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">flag</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td>以读取模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td style="text-align:center">r+</td>
<td>以读写模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td style="text-align:center">rs</td>
<td>以同步的方式读取文件。</td>
</tr>
<tr>
<td style="text-align:center">rs+</td>
<td>以同步的方式读取和写入文件。</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td>以写入模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">wx</td>
<td>类似 ‘w’，但是如果文件路径存在，则文件写入失败。</td>
</tr>
<tr>
<td style="text-align:center">w+</td>
<td>以读写模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">wx+</td>
<td>类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td>以追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">ax</td>
<td>类似 ‘a’， 但是如果文件路径存在，则文件追加失败。</td>
</tr>
<tr>
<td style="text-align:center">a+</td>
<td>以读取追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">ax+</td>
<td>类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。</td>
</tr>
</tbody>
</table>
<h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.stat(path,[callback(err,stats)]);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<p><code>fs.stat(path)</code>执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。<br>stats类中的方法有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stats.isFile()</td>
<td>如果是文件返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isDirectory()</td>
<td>如果是目录返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isBlockDevice()</td>
<td>如果是块设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isCharacterDevice()</td>
<td>如果是字符设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isSymbolicLink()</td>
<td>如果是软链接返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isFIFO()</td>
<td>如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
</tr>
<tr>
<td style="text-align:left">stats.isSocket()</td>
<td>如果是 Socket 返回 true，否则返回 false。</td>
</tr>
</tbody>
</table>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(filename,data[,options],[callback]);<span class="comment">//异步</span></div><div class="line">fs.writeFileSync(filename,data); <span class="comment">//同步</span></div></pre></td></tr></table></figure></p>
<p>如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
<ul>
<li>data  -要写入文件的数据，可以是String(字符串)或Buffer(流)对象。</li>
<li>options - 该参数是一个对象，包含{encoding,mode,flag}。默认编码为utf8,模式为0666，flag为’w’;</li>
</ul>
<h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.appendFile(filename,data[,options],[callback]);<span class="comment">//同步</span></div><div class="line">fs.appendFileSync(filename,data[,options]); <span class="comment">//同步</span></div></pre></td></tr></table></figure></p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.read(fd,buffer,offset,length,position,[callback]);<span class="comment">//异步</span></div><div class="line"><span class="keyword">var</span> buf = fs.readFile(filename,[encoding],[callback(err,data)]);<span class="comment">//异步读取</span></div><div class="line"><span class="keyword">var</span> buf = fs.readFileSync(filename,[encoding]);<span class="comment">//同步读取</span></div></pre></td></tr></table></figure></p>
<ul>
<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>
<li>buffer - 数据写入的缓冲区。</li>
<li>offset - 缓冲区写入的写入偏移量。</li>
<li>length - 要从文件中读取的字节数。</li>
<li>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li>encoding，编码格式，该项是可选的。</li>
</ul>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.close(fd,callback);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<ul>
<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>
</ul>
<h2 id="截取文件"><a href="#截取文件" class="headerlink" title="截取文件"></a>截取文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.ftruncate(fd,len,callback);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<ul>
<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>
<li>len - 文件内容截取的长度。</li>
</ul>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.unlink(path,callback);</div></pre></td></tr></table></figure></p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(path[,mode],callback);</div></pre></td></tr></table></figure></p>
<ul>
<li>mode - 设置目录权限，默认为 0777。</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.readdir(path,callback);</div></pre></td></tr></table></figure></p>
<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.rmdir(path,callback);</div></pre></td></tr></table></figure></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[canvas画Material风格的loadingView]]></title>
      <url>http://www.foreverz.cn/2016/10/03/loadingView/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>之前看到一个撸Material风格的loadingView的<a href="http://androidwing.net/index.php/73" target="_blank" rel="external">文章</a>，里面也有一个SVG做出来效果的<a href="https://material.uplabs.com/posts/material-loader-interface" target="_blank" rel="external">Demo</a>,个人觉得也很好玩，就顺手也做了一个。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>开头上源码和效果：</p>
<p> </p><p data-height="265" data-theme-id="0" data-slug-hash="GjrzXK" data-default-tab="js,result" data-user="foreveryuan" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/foreveryuan/pen/GjrzXK/" target="_blank" rel="external">loadingView</a> by Mervyn (<a href="http://codepen.io/foreveryuan" target="_blank" rel="external">@foreveryuan</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>大家也可以直接去我的github上查看源码:<a href="https://github.com/zmyforever1/loadingView" target="_blank" rel="external">传送门</a>;</p>
<p>这个使用canvas实现的动画效果，svg实现可以去看上面的链接，下面就来看看用canvas的实现。</p>
<h2 id="canvas三剑客"><a href="#canvas三剑客" class="headerlink" title="canvas三剑客"></a>canvas三剑客</h2><p>使用canvas最先登场的当然就是canvas三剑客了，先在HTML添加canvas标签，设置好宽高，然后在JS里获取DOM对象，然后使用画布方法。</p>
<h2 id="第一步，画圆"><a href="#第一步，画圆" class="headerlink" title="第一步，画圆"></a>第一步，画圆</h2><p>最先开始画两个圆。圆的颜色是白色的，所以先在CSS中把背景改为蓝色才能显示出来。<br></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> can = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = can.getContext(<span class="string">"2d"</span>);</div><div class="line"><span class="keyword">var</span> mWidth = canvas.width; <span class="comment">//画布的宽</span></div><div class="line"><span class="keyword">var</span> mHeight = canvas.height; <span class="comment">//画布的高</span></div><div class="line"><span class="keyword">var</span> mMaxOffset = <span class="number">150</span>; <span class="comment">//圆最大偏移量</span></div><div class="line"><span class="keyword">var</span> mMaxRadius = <span class="number">30</span>; <span class="comment">//圆半径</span></div><div class="line"><span class="keyword">var</span> mColor = <span class="string">'#fff'</span>; <span class="comment">//颜色</span></div><div class="line"><span class="keyword">var</span> mOffset = <span class="number">0</span>; <span class="comment">//偏移量</span></div><div class="line"><span class="keyword">var</span> mDegrees = <span class="number">0</span>; <span class="comment">//画布转角</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.arc(mWidth / <span class="number">2</span>, mHeight / <span class="number">2</span> - mOffset, mMaxRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>); <span class="comment">//在中心点上方mOffset处画圆</span></div><div class="line">    ctx.closePath();</div><div class="line">    ctx.fillStyle = mColor;</div><div class="line">    ctx.fill();</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.arc(mWidth / <span class="number">2</span>, mHeight / <span class="number">2</span> + mOffset, mMaxRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>); <span class="comment">//在中心点下方mOffset处画圆</span></div><div class="line">    ctx.closePath();</div><div class="line">    ctx.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时画布上会出现一个圆，因为这时这两个圆是重合在一起的。</p>
<h2 id="第二步，旋转"><a href="#第二步，旋转" class="headerlink" title="第二步，旋转"></a>第二步，旋转</h2><p>那接下来就是要使画布旋转起来。这时就需要用到定时器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    drawCircle();</div><div class="line">    rotate();</div><div class="line">    <span class="keyword">var</span> present = mDegrees / <span class="number">360</span>;</div><div class="line">    <span class="keyword">if</span> (present &lt; <span class="number">0.5</span>) &#123;</div><div class="line">        mOffset = mMaxOffset * present; <span class="comment">//改变圆心位置，使其靠近中心点</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mOffset = mMaxOffset * (<span class="number">1</span> - present);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">30</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    canvas.style.transform = <span class="string">`rotate(<span class="subst">$&#123;mDegrees&#125;</span>deg)`</span>; <span class="comment">//使canvas旋转</span></div><div class="line">    mDegrees += <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (mDegrees == <span class="number">360</span>) &#123;</div><div class="line">        mDegrees = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>rotate()</code>函数改变旋转角度，然后使用定时器不停的使画布旋转起来。<br>并且在定时器中对画布旋转角度进行了判断，如果画布转角小于180deg，则使两个圆的偏移量增大，当大于180deg时，则让两个圆的偏移量减小。这时其实会看到两个圆和画布一起在旋转。</p>
<h2 id="第三步，粘合动画"><a href="#第三步，粘合动画" class="headerlink" title="第三步，粘合动画"></a>第三步，粘合动画</h2><p>最后就是绘制两个圆在靠近和分开时的粘合动画了。这里用到了canvas方法里的绘制二次贝塞尔曲线quadraticCurveTo方法;<br>首先在定时器最后加上这句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (present &lt;= <span class="number">0.375</span> || present &gt;= <span class="number">0.625</span>) drawPath(present); <span class="comment">//当两圆接触时绘制粘合动画</span></div></pre></td></tr></table></figure></p>
<p>然后，就是粘合动画函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawPath</span>(<span class="params">present</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> suppoetOffset = -mMaxRadius;</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.moveTo(mWidth / <span class="number">2</span> - mMaxRadius, mHeight / <span class="number">2</span> - mOffset); <span class="comment">//从上圆最左点开始画线</span></div><div class="line">    ctx.lineTo(mWidth / <span class="number">2</span> + mMaxRadius, mHeight / <span class="number">2</span> - mOffset); <span class="comment">//到上圆最右点</span></div><div class="line">    <span class="keyword">if</span> (present &lt; <span class="number">0.25</span> || present &gt; <span class="number">0.75</span>) &#123; <span class="comment">//当两球相交</span></div><div class="line">        suppoetOffset = mMaxRadius;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (present &lt;= <span class="number">0.375</span>) &#123; <span class="comment">//当两球刚分离时</span></div><div class="line">        suppoetOffset = -(<span class="number">480</span> * present - <span class="number">150</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (present &gt;= <span class="number">0.625</span>) &#123; <span class="comment">//当两球快要接触时</span></div><div class="line">        suppoetOffset = <span class="number">480</span> * present - <span class="number">330</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 贝塞尔选点以中心点便宜30以内距离为控制点，另一圆边点为结束点</span></div><div class="line">    ctx.quadraticCurveTo(mWidth / <span class="number">2</span> + suppoetOffset, mHeight / <span class="number">2</span>, mWidth / <span class="number">2</span> + mMaxRadius, mHeight / <span class="number">2</span> + mOffset);</div><div class="line">    ctx.lineTo(mWidth / <span class="number">2</span> - mMaxRadius, mHeight / <span class="number">2</span> + mOffset);</div><div class="line">    ctx.quadraticCurveTo(mWidth / <span class="number">2</span> - suppoetOffset, mHeight / <span class="number">2</span>, mWidth / <span class="number">2</span> - mMaxRadius, mHeight / <span class="number">2</span> - mOffset);</div><div class="line">    ctx.closePath();</div><div class="line">    ctx.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是在两个球的左右四个点用直线和贝塞尔曲线连接起来，形成一个曲四边形，然后随着两球的距离不停的改变两个曲线的控制点，形成动态的粘合动画效果。<br>好了，到此结束，就完成了一个Material风格的loading动画。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sublime Text3的使用]]></title>
      <url>http://www.foreverz.cn/2016/10/02/Sublime%20Text3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>前端开发有很多款方便易用的编辑器和IDE，如WebStoem、Atom和Brackets等，每个编辑器都有她自己的优点和缺点，但是都不如Sublime那么全面和强大，但是刚装上的Sublime就如一张白纸一样，怎么才能把她变成娜塔莎呢？这里我就逐步介绍一些我的Sublime使用史，帮助大家的Sublime强大起来！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h2><p>Package Control插件本身是一个为了方便管理插件的插件，安装了她你的Sublime才算有了强大的基础，没有她的Sublime并不是真的Sublime。怎么安装呢？如下：<br>使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</div></pre></td></tr></table></figure>
<p>安装了Package Control，你就可以非常方便的安装其它插件了，安装方法如下：<br>使用Ctrl+Shift+P快捷键或者Tools-&gt;Command Palette打开调出面板，然后输入Install package，回车，然后就会进入插件库了，在插件库里搜索自己想装的插件，然后点击就会下载并安装了。</p>
<h2 id="生产力插件推荐"><a href="#生产力插件推荐" class="headerlink" title="生产力插件推荐"></a>生产力插件推荐</h2><blockquote>
<p>ChineseLocalizations：各国语言包<br>ConvertToUTF8：GBK编码兼容</p>
<blockquote>
<p>很多文件都是GBK编码的文件，如果其中有汉字的话，在Sublime中打开是会乱码的，而且很难恢复回来，使用这个插件就可以吧GBK转为UTF-8格式，就不会有乱码了。</p>
</blockquote>
<p>sideNav：左边栏增强<br>SideBarEnhancements：侧栏右键功能增强<br>Emment：快速编写HTML和CSS代码</p>
<blockquote>
<p>Emment，大名鼎鼎啊，原名Zencoding，动态扩展HTML和CSS的缩写，前端开发必不可少的东东，略过。</p>
</blockquote>
<p>Sublime CodeIntel代码提示插件<br>JavaScript Completions：js全能提示<br>All Autocomplete：搜索所有打开的文件来寻找匹配的提示词<br>HTML/CSS/JVScriptPrettify：代码格式化<br>JsFormat：JS代码格式化<br>PHPCodeBeautifier：PHP代码格式化<br>Alignment：代码对齐<br>Color Highlighter：颜色高亮显示<br>CSScomb： CSS属性排序<br>Autoprefixer配置浏览器兼容<br>SublimeLinter：代码校验<br>Bracket Highlighter：匹配括号<br>AutoFileName: 文件路径自动提示<br>ColorPicker：调色盘<br>TrailingSpaces：高亮显示多余空格和Tab<br>LiveStyle：实时预览<br>Keymaps：快速查找所有插件的快捷键<br>Ternimal：CMD控制台<br>MarkDown Preview：MarkDown生成HTML文件、预览功能</p>
</blockquote>
<p>由于时间有限，很多插件都没有仔细介绍，有空我会慢慢补上插件的功能介绍，大家也可以自行摸索或者Google，最好去github上找到项目看官方的介绍。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS实现随机颜色的三种方式和颜色格式的转化]]></title>
      <url>http://www.foreverz.cn/2016/09/29/js%E9%9A%8F%E6%9C%BA%E9%A2%9C%E8%89%B2/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>前端的颜色表示方式多种，一种是以3个或6个十六进制的数子表示，一种是RGB的数字形式，还有一种是直接以颜色的英文来表示。这三种都是不支持透明色的。所以还有RGBA的表式方式，在RGB的的基础上加入了Alpha透明，使网页可以展现更加复杂绚丽的效果。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="随机颜色"><a href="#随机颜色" class="headerlink" title="随机颜色"></a>随机颜色</h2><p>在平时的码农日常中，经常会用到求随机颜色的地方，下面是我总结的几种简单的实现随机颜色的方式：</p>
<h3 id="十六进制格式（-000000-FFFFFF）"><a href="#十六进制格式（-000000-FFFFFF）" class="headerlink" title="十六进制格式（#000000-#FFFFFF）"></a>十六进制格式（#000000-#FFFFFF）</h3><p>第一种是比较简单的方法，这种方法是先随机生成ffffff以内16进制数，然后判断位数，少于6位的用while循环在前面加0，凑够6位。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomHexColor</span>(<span class="params"></span>) </span>&#123; <span class="comment">//随机生成十六进制颜色</span></div><div class="line">    <span class="keyword">var</span> hex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777216</span>).toString(<span class="number">16</span>); <span class="comment">//生成ffffff以内16进制数</span></div><div class="line">    <span class="keyword">while</span> (hex.length &lt; <span class="number">6</span>) &#123; <span class="comment">//while循环判断hex位数，少于6位前面加0凑够6位</span></div><div class="line">        hex = <span class="string">'0'</span> + hex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'#'</span> + hex; <span class="comment">//返回‘#’开头16进制颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有一种比较方便但是比较难懂的方法，需要用到位运算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomHexColor</span>(<span class="params"></span>) </span>&#123;	<span class="comment">//随机生成十六进制颜色</span></div><div class="line">	<span class="keyword">return</span> <span class="string">'#'</span> + (<span class="string">'00000'</span> + (<span class="built_in">Math</span>.random() * <span class="number">0x1000000</span> &lt;&lt; <span class="number">0</span>).toString(<span class="number">16</span>)).substr(<span class="number">-6</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按执行顺序可以分为以下六步：</p>
<ol>
<li>先执行<code>Math.random() * 0x1000000</code>，其中0x1000000=0xffffff+1，因为Math.random()取不到1，所以+1，这样就会生成一个1-16777216(不包含)以内的浮点数。</li>
<li>然后执行<code>&lt;&lt;0</code>，这是取整运算，去掉后面的小数点。这时为一个16777216(不包含)以内的十进制数。</li>
<li>之后执行<code>.toString(16)</code>，把十进制数转化为六位以下16进制数。</li>
<li>再后执行<code>&#39;00000&#39;+</code>，这时因为之前生成的16进制数最少可能仅一位，在前面加上5个0。</li>
<li>最后执行<code>.substr(-6)</code>，是去从-6开始的后面所有字符串，也就是最后6位数。</li>
<li>前面加上<code>#</code>并<code>retuen</code>。</li>
</ol>
<h3 id="RGB格式"><a href="#RGB格式" class="headerlink" title="RGB格式"></a>RGB格式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRgbColor</span>(<span class="params"></span>) </span>&#123; <span class="comment">//随机生成RGB颜色</span></div><div class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span></div><div class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span></div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span></div><div class="line">    <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>; <span class="comment">//返回rgb(r,g,b)格式颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RGBA格式"><a href="#RGBA格式" class="headerlink" title="RGBA格式"></a>RGBA格式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRgbaColor</span>(<span class="params"></span>) </span>&#123; <span class="comment">//随机生成RGBA颜色</span></div><div class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span></div><div class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span></div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span></div><div class="line">    <span class="keyword">var</span> alpha = <span class="built_in">Math</span>.random(); <span class="comment">//随机生成1以内a值</span></div><div class="line">    <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;alpha&#125;</span>)`</span>; <span class="comment">//返回rgba(r,g,b,a)格式颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="颜色格式转化"><a href="#颜色格式转化" class="headerlink" title="颜色格式转化"></a>颜色格式转化</h2><p>在编码过程中，经常会遇到要将颜色格式相互转化的问题,其中十六进制格式和RGB格式是可以相互转化的，但是RGBA格式由于多了前两者没有的Alpha透明属性，所以和前两者转化会丢失Alpha值，不建议进行转化，下面是我的颜色转化的方法：</p>
<h3 id="十六进制转为RGB"><a href="#十六进制转为RGB" class="headerlink" title="十六进制转为RGB"></a>十六进制转为RGB</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex2Rgb</span>(<span class="params">hex</span>) </span>&#123; <span class="comment">//十六进制转为RGB</span></div><div class="line">    <span class="keyword">var</span> rgb = []; <span class="comment">// 定义rgb数组</span></div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^\#[0-9A-F]&#123;3&#125;$/i</span>.test(hex)) &#123; <span class="comment">//判断传入是否为#三位十六进制数</span></div><div class="line">        <span class="keyword">let</span> sixHex = <span class="string">'#'</span>;</div><div class="line">        hex.replace(<span class="regexp">/[0-9A-F]/ig</span>, <span class="function"><span class="keyword">function</span>(<span class="params">kw</span>) </span>&#123;</div><div class="line">            sixHex += kw + kw; <span class="comment">//把三位16进制数转化为六位</span></div><div class="line">        &#125;);</div><div class="line">        hex = sixHex; <span class="comment">//保存回hex</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^#[0-9A-F]&#123;6&#125;$/i</span>.test(hex)) &#123; <span class="comment">//判断传入是否为#六位十六进制数</span></div><div class="line">        hex.replace(<span class="regexp">/[0-9A-F]&#123;2&#125;/ig</span>, <span class="function"><span class="keyword">function</span>(<span class="params">kw</span>) </span>&#123;</div><div class="line">            rgb.push(<span class="built_in">eval</span>(<span class="string">'0x'</span> + kw)); <span class="comment">//十六进制转化为十进制并存如数组</span></div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;rgb.join(<span class="string">','</span>)&#125;</span>)`</span>; <span class="comment">//输出RGB格式颜色</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Input <span class="subst">$&#123;hex&#125;</span> is wrong!`</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">'rgb(0,0,0)'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RGB转为十六进制"><a href="#RGB转为十六进制" class="headerlink" title="RGB转为十六进制"></a>RGB转为十六进制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2Hex</span>(<span class="params">rgb</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^rgb\((\d&#123;1,3&#125;\,)&#123;2&#125;\d&#123;1,3&#125;\)$/i</span>.test(rgb)) &#123; <span class="comment">//test RGB</span></div><div class="line">        <span class="keyword">var</span> hex = <span class="string">'#'</span>; <span class="comment">//定义十六进制颜色变量</span></div><div class="line">        rgb.replace(<span class="regexp">/\d&#123;1,3&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">kw</span>) </span>&#123; <span class="comment">//提取rgb数字</span></div><div class="line">            kw = <span class="built_in">parseInt</span>(kw).toString(<span class="number">16</span>); <span class="comment">//转为十六进制</span></div><div class="line">            kw = kw.length &lt; <span class="number">2</span> ? <span class="number">0</span> + kw : kw; <span class="comment">//判断位数，保证两位</span></div><div class="line">            hex += kw; <span class="comment">//拼接</span></div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> hex; <span class="comment">//返回十六进制</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Input <span class="subst">$&#123;rgb&#125;</span> is wrong!`</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">'#000'</span>; <span class="comment">//输入格式错误,返回#000</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是我在平时遇到的关于颜色处理方面的问题，大家有遇到什么奇怪的问题和更好的解决方法可以交流沟通一下。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>http://www.foreverz.cn/2016/09/27/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>先是使用了为知笔记，接触到Markdown,后来又在github玩起了博客，Markdown就更加必不可少了，在使用为知笔记的过程中，由于为知笔记有很多的bug，自己也是新手，所以用的很不顺手，走了很多的弯路，后来改用sublime编辑，果然好很多，推荐大家也用sublime进行编辑。下面呢是我在用Markdown过程中学到到语法和总结的一些使用心得和方法。持续更新哦！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>由于我使用了<a href="https://github.com/MOxFIVE/yelee" target="_blank" rel="external">yelee</a>主题，所以显示的效果会不一样哦。</p>
<h2 id="关于标题"><a href="#关于标题" class="headerlink" title="关于标题"></a>关于标题</h2><p>在行首插入 1 到 6个#，分别表示标题 1 到标题 6，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 这是标题1</div><div class="line">## 这是标题2</div><div class="line">### 这是标题3</div><div class="line">#### 这是标题4</div><div class="line">##### 这是标题5</div><div class="line">###### 这是标题6</div></pre></td></tr></table></figure></p>
<p>效果展示：<br><img src="http://p1.bpimg.com/4851/66c2d7412399f8cf.png" alt="标题"></p>
<h2 id="显示文本"><a href="#显示文本" class="headerlink" title="显示文本"></a>显示文本</h2><h3 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h3><p>文本顶格写就会显示普通文本。</p>
<h3 id="超链接文本"><a href="#超链接文本" class="headerlink" title="超链接文本"></a>超链接文本</h3><p>直接输入超链接的URL会自动变成可链接的形式。<br><a href="http://foreverz.cn" target="_blank" rel="external">http://foreverz.cn</a></p>
<h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><pre><code>在行首增加1个tab或者4个空格就可以达到这种效果。
</code></pre><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>在连续几行的开头加入1个tab或者8个空格，这段文本就会形成文本块。还可以多加tab或空格形成层级。</p>
<pre><code>欢迎到访。
    我已经在你的世界路过。
希望您开心快乐每一天。
</code></pre><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><p>使行内部分文字高亮，来强调显示需要用一对反引号``(tab上方的按键)包围起来。<br><code>HTML</code>,<code>CSS</code>,<code>javascript</code>;</p>
<h2 id="粗体、斜体、删除线"><a href="#粗体、斜体、删除线" class="headerlink" title="粗体、斜体、删除线"></a>粗体、斜体、删除线</h2><p>粗体：在文字前后添加 ** (注意符号与文字间不要有空格）<br>斜体：在文字前后添加 *<br>删除线：在文字前后添加 ~~<br>语法和显示效果如下：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果展示</th>
</tr>
</thead>
<tbody>
<tr>
<td>*斜体1*</td>
<td><em>斜体1</em></td>
</tr>
<tr>
<td>_斜体2_</td>
<td><em>斜体2</em></td>
</tr>
<tr>
<td>**粗体1**</td>
<td><strong>粗体1</strong></td>
</tr>
<tr>
<td>__粗体2__</td>
<td><strong>粗体2</strong></td>
</tr>
<tr>
<td>~~删除线~~</td>
<td><del>删除线</del></td>
</tr>
</tbody>
</table>
<p>然后自由搭配也可以实现<strong><em>斜粗体</em></strong>和<strong><em><del>斜粗删除线</del></em></strong>等效果</p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p>[描述](链接地址 悬停显示)，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[我的博客](http://foreverz.cn &apos;forever&apos;)</div></pre></td></tr></table></figure></p>
<p>或者这样表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[我的博客][forever]</div><div class="line">[forever]:http://foreverz.cn &apos;forever&apos;</div><div class="line">[forever]:http://foreverz.cn &quot;forever&quot;</div><div class="line">[forever]:http://foreverz.cn (forever)</div></pre></td></tr></table></figure></p>
<p>这里的三种定义都是完全相同的。这是用到了<strong>URL标识符</strong>，可以达到复用的目的，一般把全文的URL标识符放到文章末尾，这样比较干净，以方便修改。<br>效果展示:<br><a href="http://foreverz.cn" title="forever" target="_blank" rel="external">我的博客</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[![alt](imgSrc &apos;title&apos;)](hrefURL)</div></pre></td></tr></table></figure></p>
<p>alt是在图片加载失败时显示的替代文字，imgSrc是图片的URL，title是鼠标悬停图片上时现实的文本，hrefURL图片的超链接地址。<br>也可以写成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[![alt](imgSrc &apos;title&apos;)][href]</div><div class="line">[href]:hrefURL</div></pre></td></tr></table></figure></p>
<p>这样也是复用的写法。<br>其中，alt，title和href都可以省略，省略后的最简单的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](imgSrc)</div></pre></td></tr></table></figure></p>
<p>或者这样表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">![alt][id]</div><div class="line">[id]:imgSrc &apos;title&apos;</div></pre></td></tr></table></figure></p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">![](http://foreverz.cn/img/avatar.png &apos;forever&apos;)</div><div class="line">[![forever](http://foreverz.cn/img/avatar.png &apos;forever&apos;)](http://foreverz.cn)</div></pre></td></tr></table></figure></p>
<p>效果展示：<br><img src="http://foreverz.cn/img/avatar.png" alt="" title="forever"><br><a href="http://foreverz.cn" target="_blank" rel="external"><img src="http://foreverz.cn/img/avatar.png" alt="forever" title="forever"></a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在行首增加 1. 、 2. 、 3. ，即数字和英文句点, 不要求数字一定要连续，可以都是 1.，后面加一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 有序列表</div><div class="line">1. 有序列表</div><div class="line">4. 有序列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<p>此外还有二级列表和三级列表等，语法如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 有序列表</div><div class="line">	1.1 二级列表</div><div class="line">1. 有序列表</div><div class="line">	2.1 二级列表</div><div class="line">		2.1.1 二级列表</div><div class="line">4. 有序列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ol>
<li>有序列表<br> 1.1 二级列表</li>
<li>有序列表<br> 2.1 二级列表<pre><code>2.1.1 二级列表
</code></pre></li>
<li>有序列表</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在行首增加 * 、+ 或 -，后面跟一个空格，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* 无序列表</div><div class="line">* 无序列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ul>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<p>此外还有二级列表和三级列表等，语法如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 无序列表</div><div class="line">	* 二级列表</div><div class="line">* 无序列表</div><div class="line">	* 二级列表</div><div class="line">		* 三级列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ul>
<li>无序列表<ul>
<li>二级列表</li>
</ul>
</li>
<li>无序列表<ul>
<li>二级列表<ul>
<li>三级列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用列表时需要在后面加上空行与其它内容区隔开，否则会被加入最后一个列表里。</p>
</blockquote>
<h3 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h3><p>列表可被转换为任务清单，只要在列表项开头加上<a href="中间有空格"> </a>或者[x],(分别表示已完成和未完成)。<br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- [ ]HTML</div><div class="line">- [ ]CSS</div><div class="line">- [x]JavaScript</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ul>
<li>[ ]HTML</li>
<li>[ ]CSS</li>
<li>[x]JavaScript</li>
</ul>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>Markdown中的转义字符为\，可以转义的有：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>\ 反斜杠</td>
<td>` 反引号</td>
<td>* 星号</td>
<td>_ 下划线</td>
</tr>
<tr>
<td>{ } 大括号</td>
<td>[ ] 中括号</td>
<td>( ) 小括号</td>
<td># 井号</td>
</tr>
<tr>
<td>+ 加号</td>
<td>- 减号</td>
<td>. 英文句号</td>
<td>! 感叹号</td>
</tr>
</tbody>
</table>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| 为知笔记|更新 | 版本 |</div><div class="line">|---------|-----|------|</div><div class="line">| WizNote | Markdown| Latest |</div></pre></td></tr></table></figure>
<p>效果展示：</p>
<table>
<thead>
<tr>
<th>blog</th>
<th>system</th>
<th>theme</th>
</tr>
</thead>
<tbody>
<tr>
<td>github page</td>
<td>hexo</td>
<td>yelee</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用表格必须在前后加上空行与其它内容区隔开，否则表格无效。</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用文本"><a href="#引用文本" class="headerlink" title="引用文本"></a>引用文本</h3><p>在文字前添加 &gt;<br>效果展示：</p>
<blockquote>
<p>如果你无法简洁的表达你的想法，那只说明你还不够了解它。 – 阿尔伯特·爱因斯坦</p>
</blockquote>
<p>多级引用<br>格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;中国</div><div class="line">&gt;&gt;浙江</div><div class="line">&gt;&gt;&gt;杭州</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<blockquote>
<p>中国</p>
<blockquote>
<p>浙江</p>
<blockquote>
<p>杭州</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>使用引用时需要在引用后加上空行与其它内容区隔开，否则会被加入引用。</li>
</ul>
<h3 id="引用代码"><a href="#引用代码" class="headerlink" title="引用代码"></a>引用代码</h3><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用一个 ` 将语句包起来。<br>多行则要在代码前后增加 三个反单引号： ```,后面写上所引用的语言<br>格式如下<br>```javascript<br>for (var i = 0; i &lt; 100; i++)<br>{<br>    console.log(“hello markdown!\n”);<br>}<br>效果展示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hello markdown!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h2><p>在任何你想要展示Markdown 笔记目录的地方，添加 [TOC] ， 在阅读模式下，标题1~6样式的内容会被提取出来作为目录，相当于大纲功能。<br><img src="http://p1.bpimg.com/4851/4172c368837ea17b.png" alt=""></p>
</the>]]></content>
    </entry>
    
  
  
</search>

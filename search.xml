<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[二叉树与js]]></title>
      <url>http://www.foreverz.cn/2016/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8Ejs/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>二叉树是非常基础有非常重要的数据结构，在一些场合有着非常重要的左右。掌握二叉树对编写高质量代码、减少代码量有很大的促进作用！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="关于二叉树"><a href="#关于二叉树" class="headerlink" title="关于二叉树"></a>关于二叉树</h2><p>二叉树是一种特殊的树， 非常适合计算机处理数据， 所以对于程序员来说掌握二叉树是非常有必要的。</p>
<h3 id="二叉树是什么"><a href="#二叉树是什么" class="headerlink" title="二叉树是什么"></a>二叉树是什么</h3><p>二叉树是一种特殊的树，有以下两个特征：</p>
<ol>
<li>二叉树的每个结点的度都不大于2；</li>
<li>二叉树每个结点的孩子结点次序不能任意颠倒。</li>
</ol>
<h2 id="为什么使用二叉树"><a href="#为什么使用二叉树" class="headerlink" title="为什么使用二叉树"></a>为什么使用二叉树</h2><p>二叉树的前序遍历可以用来显示目录结构等；中序遍历可以实现表达式树，在编译器底层很有用；后序遍历可以用来实现计算目录内的文件及其信息等。<br>二叉树是非常重要的数据结构， 其中二叉树的遍历要使用到栈和队列还有递归等，很多其它数据结构也都是基于二叉树的基础演变而来的。熟练使用二叉树在很多时候可以提升程序的运行效率，减少代码量，使程序更易读。<br>二叉树不仅是一种数据结构，也是一种编程思想。学好二叉树是程序员进阶的一个必然进程。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树有深度遍历和广度遍历， 深度遍历有前序、 中序和后序三种遍历方法。 广度遍历就是层次遍历。 因为树的定义本身就是递归定义， 因此采用递归的方法实现树的三种遍历容易理解而且代码比较简洁。<br>有时对一段代码来说， 可读性有时比代码本身的效率要重要的多。</p>
<p>四种遍历的主要思想：</p>
<ol>
<li>前序遍历：访问根–&gt;遍历左子树–&gt;遍历右子树;</li>
<li>中序遍历：遍历左子树–&gt;访问根–&gt;遍历右子树;</li>
<li>后序遍历：遍历左子树–&gt;遍历右子树–&gt;访问根;</li>
<li>广度遍历：按照层次一层层遍历;</li>
</ol>
<p>例如“(a+b*c)-d/e”,该表达式用二叉树表示如图：</p>
<div style="text-align: center"><br><img src="http://oef1ordmv.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""><br></div>

<p>对该二叉树进行深度和广度遍历为：</p>
<p>前序遍历：- + a <em> b c / d e<br>中序遍历：a + b </em> c - d / e<br>后序遍历：a b c <em> + d e / -<br>广度遍历：- + / a </em> d e b c</p>
<h2 id="js中的二叉树"><a href="#js中的二叉树" class="headerlink" title="js中的二叉树"></a>js中的二叉树</h2><p>上述二叉树<code>(a+b*c)-d/e</code>在js中可以用对象的形式表示出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tree = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"-"</span>,</div><div class="line">    <span class="attr">left</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">'+'</span>,</div><div class="line">        <span class="attr">left</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'a'</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'*'</span>,</div><div class="line">            <span class="attr">left</span>: &#123;</div><div class="line">                <span class="attr">value</span>: <span class="string">'b'</span>,</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">right</span>: &#123;</div><div class="line">                <span class="attr">value</span>: <span class="string">'c'</span>,</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">right</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">'/'</span>,</div><div class="line">        <span class="attr">left</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'d'</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">right</span>: &#123;</div><div class="line">            <span class="attr">value</span>: <span class="string">'e'</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="js中二叉树的深度遍历"><a href="#js中二叉树的深度遍历" class="headerlink" title="js中二叉树的深度遍历"></a>js中二叉树的深度遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preListRec = []; <span class="comment">//定义保存先序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> preOrderRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        preListRec.push(node.value); <span class="comment">//将结点的值存入数组中</span></div><div class="line">        preOrderRec(node.left); <span class="comment">//递归遍历左子树</span></div><div class="line">        preOrderRec(node.right); <span class="comment">//递归遍历右子树</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">preOrderRec(tree);</div><div class="line"><span class="built_in">console</span>.log(preListRec);</div><div class="line"><span class="comment">//[ '-', '+', 'a', '*', 'b', 'c', '/', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<p>先序递归遍历的思路是先遍历根结点，将值存入数组，然后递归遍历：先左结点，将值存入数组，继续向下遍历，然后再回溯遍历右结点，将值存入数组，这样递归循环。</p>
<h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preListUnRec = []; <span class="comment">//定义保存先序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> preOrderUnRecursion = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> stack = [node]; <span class="comment">//将二叉树压入栈</span></div><div class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span>) &#123; <span class="comment">//如果栈为空，则循环遍历</span></div><div class="line">            node = stack.pop(); <span class="comment">//从栈中取出一个结点</span></div><div class="line">            preListUnRec.push(node.value); <span class="comment">//将取出结点的值存入数组中</span></div><div class="line">            <span class="keyword">if</span> (node.right) stack.push(node.right); <span class="comment">//如果存在右子树，将右子树压入栈</span></div><div class="line">            <span class="keyword">if</span> (node.left) stack.push(node.left); <span class="comment">//如果存在左子树，将左子树压入栈</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">preOrderUnRecursion(tree);</div><div class="line"><span class="built_in">console</span>.log(preListUnRec);</div><div class="line"><span class="comment">//[ '-', '+', 'a', '*', 'b', 'c', '/', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<p>先序非递归遍历是利用了栈，将根结点放入栈中，然后再取出来，将值放入结果数组，然后如果存在右子树，将右子树压入栈，如果存在左子树，将左子树压入栈，然后循环判断栈是否为空，重复上述步骤。</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inListRec = []; <span class="comment">//定义保存中序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> inOrderRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        inOrderRec(node.left); <span class="comment">//递归遍历左子树</span></div><div class="line">        inListRec.push(node.value); <span class="comment">//将结点的值存入数组中</span></div><div class="line">        inOrderRec(node.right); <span class="comment">//递归遍历右子树</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">inOrderRec(tree);</div><div class="line"><span class="built_in">console</span>.log(inListRec);</div><div class="line"><span class="comment">//[ 'a', '+', 'b', '*', 'c', '-', 'd', '/', 'e' ]</span></div></pre></td></tr></table></figure>
<p>中序递归遍历的思路是先递归遍历左子树，从最后一个左子树开始存入数组，然后回溯遍历双亲结点，再是右子树，这样递归循环。</p>
<h4 id="非递归遍历-1"><a href="#非递归遍历-1" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inListUnRec = []; <span class="comment">//定义保存中序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> inOrderUnRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> stack = []; <span class="comment">//建立一个栈</span></div><div class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span> || node) &#123; <span class="comment">//如果栈不为空或结点不为空，则循环遍历</span></div><div class="line">            <span class="keyword">if</span> (node) &#123; <span class="comment">//如果结点不为空</span></div><div class="line">                stack.push(node); <span class="comment">//将结点压入栈</span></div><div class="line">                node = node.left; <span class="comment">//将左子树作为当前结点</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//左子树为空，即没有左子树的情况</span></div><div class="line">                node = stack.pop(); <span class="comment">//将结点取出来</span></div><div class="line">                inListUnRec.push(node.value); <span class="comment">//将取出结点的值存入数组中</span></div><div class="line">                node = node.right; <span class="comment">//将右结点作为当前结点</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">inOrderUnRec(tree);</div><div class="line"><span class="built_in">console</span>.log(inListUnRec);</div><div class="line"><span class="comment">//[ 'a', '+', 'b', '*', 'c', '-', 'd', '/', 'e' ]</span></div></pre></td></tr></table></figure>
<p>非递归遍历的思路是将当前结点压入栈，然后将左子树当做当前结点，如果当前结点为空，将双亲结点取出来，将值保存进数组，然后将右子树当做当前结点，进行循环。</p>
<p>###后续遍历</p>
<h4 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> postListRec = []; <span class="comment">//定义保存后序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> postOrderRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        postOrderRec(node.left); <span class="comment">//递归遍历左子树</span></div><div class="line">        postOrderRec(node.right); <span class="comment">//递归遍历右子树</span></div><div class="line">        postListRec.push(node.value); <span class="comment">//将结点的值存入数组中</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">postOrderRec(tree);</div><div class="line"><span class="built_in">console</span>.log(postListRec);</div><div class="line"><span class="comment">//[ 'a', 'b', 'c', '*', '+', 'd', 'e', '/', '-' ]</span></div></pre></td></tr></table></figure>
<p>递归遍历也是和上面的差不多，先走左子树，当左子树没有孩子结点时，将此结点的值放入数组中，然后回溯遍历双亲结点的右结点，递归遍历。</p>
<h4 id="非递归遍历-2"><a href="#非递归遍历-2" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> postListUnRec = []; <span class="comment">//定义保存后序遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> postOrderUnRec = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> stack = [node]; <span class="comment">//将二叉树压入栈</span></div><div class="line">        <span class="keyword">var</span> tmp = <span class="literal">null</span>; <span class="comment">//定义缓存变量</span></div><div class="line">        <span class="keyword">while</span> (stack.length !== <span class="number">0</span>) &#123; <span class="comment">//如果栈不为空，则循环遍历</span></div><div class="line">            tmp = stack[stack.length - <span class="number">1</span>]; <span class="comment">//将栈顶的值保存在tmp中</span></div><div class="line">            <span class="keyword">if</span> (tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) &#123; <span class="comment">//如果存在左子树</span></div><div class="line">                stack.push(tmp.left); <span class="comment">//将左子树结点压入栈</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp.right &amp;&amp; node !== tmp.right) &#123; <span class="comment">//如果结点存在右子树</span></div><div class="line">                stack.push(tmp.right); <span class="comment">//将右子树压入栈中</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                postListUnRec.push(stack.pop().value);</div><div class="line">                node = tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">postOrderUnRec(tree);</div><div class="line"><span class="built_in">console</span>.log(postListUnRec);</div><div class="line"><span class="comment">//[ 'a', 'b', 'c', '*', '+', 'd', 'e', '/', '-' ]</span></div></pre></td></tr></table></figure>
<p>这里使用了一个tmp变量来记录上一次出栈、入栈的结点。思路是先把根结点和左树推入栈，然后取出左树，再推入右树，取出，最后取根结点。</p>
<h2 id="js中二叉树的广度遍历"><a href="#js中二叉树的广度遍历" class="headerlink" title="js中二叉树的广度遍历"></a>js中二叉树的广度遍历</h2><p>广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。<br>实现原理：使用数组模拟队列，首先将根结点归入队列。当队列不为空时，执行循环：取出队列的一个结点，如果该节点有左子树，则将该节点的左子树存入队列；如果该节点有右子树，则将该节点的右子树存入队列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> breadthList = []; <span class="comment">//定义保存广度遍历结果的数组</span></div><div class="line"><span class="keyword">var</span> breadthTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123; <span class="comment">//判断二叉树是否为空</span></div><div class="line">        <span class="keyword">var</span> que = [node]; <span class="comment">//将二叉树放入队列</span></div><div class="line">        <span class="keyword">while</span> (que.length !== <span class="number">0</span>) &#123; <span class="comment">//判断队列是否为空</span></div><div class="line">            node = que.shift(); <span class="comment">//从队列中取出一个结点</span></div><div class="line">            breadthList.push(node.value); <span class="comment">//将取出结点的值保存到数组</span></div><div class="line">            <span class="keyword">if</span> (node.left) que.push(node.left); <span class="comment">//如果存在左子树，将左子树放入队列</span></div><div class="line">            <span class="keyword">if</span> (node.right) que.push(node.right); <span class="comment">//如果存在右子树，将右子树放入队列</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">breadthTraversal(tree);</div><div class="line"><span class="built_in">console</span>.log(breadthList);</div><div class="line"><span class="comment">//[ '-', '+', '/', 'a', '*', 'd', 'e', 'b', 'c' ]</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树的遍历还是比较难懂的，如果想要好好的理解，可以把程序转化一下，比如递归的程序可以吧每个递归都写成实际的函数嵌套，这样一层层的直接执行代码，不用递归，就很容易读懂了。</p>
<p>参考资料：<a href="https://segmentfault.com/a/1190000004620352" target="_blank" rel="external">https://segmentfault.com/a/1190000004620352</a></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js函数、原型与继承]]></title>
      <url>http://www.foreverz.cn/2016/10/18/js%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>js是可以面向对象编程的，而面向对象很重要的一个特性就是继承，js的继承是通过原型链模拟的，达到了原型链的效果，我们就探讨一下原型链到底是个什么东西。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="函数的概念和作用"><a href="#函数的概念和作用" class="headerlink" title="函数的概念和作用"></a>函数的概念和作用</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块，是用来帮助我们封装、调用代码的最方便的工具！</p>
<h2 id="函数的创建方法"><a href="#函数的创建方法" class="headerlink" title="函数的创建方法"></a>函数的创建方法</h2><p>函数的创建方法有三种：</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;</div><div class="line">fun();</div></pre></td></tr></table></figure>
<p>在这种定义方式下，函数不属于任何对象，但是在js中它始终是默认的全局对象！函数必须用<code>fun();</code>来调用，也可以在函数声明前调用，但是不调用的函数是没有用的。</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;</div><div class="line">fun();</div></pre></td></tr></table></figure>
<p>这种方式是将函数保存在变量中，也是通过<code>fun();</code>调用，但是这里因为变量有声明提前，原地赋值的特性，所以不能提前调用，只能在定义之后再使用。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="built_in">console</span>.log(<span class="string">'Hello World'</span>));</div></pre></td></tr></table></figure>
<p>这种方法是比较少见的一种函数创建方法，也是很神奇的一种方法，这里简略一下，后面会详细说明。这种方法还有一个特点，就是函数可以自调。</p>
<h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><p>函数的调用方式有四种：</p>
<h3 id="作为一个函数去调用"><a href="#作为一个函数去调用" class="headerlink" title="作为一个函数去调用"></a>作为一个函数去调用</h3><p>调用方式就是前面用过的<code>fun();</code>,以函数名+()的方式直接调用，也是我们常见的调用方法。此时函数作为全局对象调用，会使this的值成为全局对象，使用window对象作为一个变量，容易造成程序崩溃！</p>
<h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><p>函数作为对象的方法调用，会使this的值成为对象的本身！举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">say</span>: <span class="string">'Hello World!'</span>,</div><div class="line">    <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.sayHello();</div></pre></td></tr></table></figure></p>
<h3 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.say = <span class="string">"Hello World!"</span>;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.say);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fun();</div><div class="line">obj.say;	<span class="comment">//=&gt;Hello World!</span></div><div class="line">obj.sayHello();</div></pre></td></tr></table></figure>
<p>构造函数中的this<br>没有任何值，但是当用new新建<code>obj</code>对象时，this会指向<code>obj</code>，此时<code>obj</code>会继承<code>fun</code>的属相和方法成为自己的属性和方法！</p>
<h3 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><p>在js中函数是对象，是对象就有对象的方法，而<code>call()</code>和<code>apply()</code>是预定义的函数方法！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a * b);</div><div class="line">&#125;</div><div class="line">fun.call(foo, <span class="number">10</span>, <span class="number">2</span>);	<span class="comment">//=&gt;20</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a * b);</div><div class="line">&#125;</div><div class="line">fun.apply(foo, [<span class="number">10</span>, <span class="number">2</span>]);	<span class="comment">//=&gt;20</span></div></pre></td></tr></table></figure></p>
<p><code>call</code>和<code>apply</code>是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。在这里<code>foo</code>只是一个变量，没有任何属性和方法，所以用call或apply调用<code>fun</code>方法操作。<br>两个方法的区别在于call传入的是一个个普通的参数，而apply传入的是一个数组。</p>
<h2 id="函数的运行机制"><a href="#函数的运行机制" class="headerlink" title="函数的运行机制"></a>函数的运行机制</h2><p>1、在js中，js引擎会优先解析var变量和function定义！在预解析完成后从上到下逐步进行！<br>2、解析var变量时，会把值存储在“执行环境”中，而不会去赋值，也就是通常所说的声明提前，原地赋值。<br>3、在解析function时会把函数整体定义，这也就解释了为什么在function定义函数时为什么可以先调用后声明了！其实表面上看是先调用了，其实在内部机制中第一步实行的是把以function方式定义的函数先声明了！</p>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>1.在js中函数定义没有任何参数，调用该函数时可以传递任意参数！<br>2.arguments对象是数组对象。<br>3.arguments对象的length属性：获取函数的实参个数！<br>4.利用Arguments对象特性,实现模拟函数的重载的效果.</p>
<p>参考链接：<a href="http://www.cnblogs.com/Jabin/p/5804052.html" target="_blank" rel="external">http://www.cnblogs.com/Jabin/p/5804052.html</a><br>构造函数：<a href="http://www.2cto.com/kf/201402/281841.html" target="_blank" rel="external">http://www.2cto.com/kf/201402/281841.html</a><br>原型链和继承：<a href="http://www.w2bc.com/Article/10575" target="_blank" rel="external">http://www.w2bc.com/Article/10575</a><br><a href="http://www.cnblogs.com/ljchow/archive/2010/06/08/1753526.html" target="_blank" rel="external">http://www.cnblogs.com/ljchow/archive/2010/06/08/1753526.html</a><br><a href="http://www.108js.com/article/article1/10201.html?id=1092" target="_blank" rel="external">http://www.108js.com/article/article1/10201.html?id=1092</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="external">http://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html</a><br>原型链原理 <a href="http://www.cnblogs.com/xdp-gacl/p/3704722.html" target="_blank" rel="external">http://www.cnblogs.com/xdp-gacl/p/3704722.html</a><br><a href="http://2660311.blog.51cto.com/2650311/1358226/" target="_blank" rel="external">http://2660311.blog.51cto.com/2650311/1358226/</a><br>函数创建过程 <a href="http://blog.jobbole.com/19795/" target="_blank" rel="external">http://blog.jobbole.com/19795/</a><br>继承：<a href="http://uule.iteye.com/blog/1158829" target="_blank" rel="external">http://uule.iteye.com/blog/1158829</a><br><a href="http://blog.csdn.net/james521314/article/details/8645815" target="_blank" rel="external">http://blog.csdn.net/james521314/article/details/8645815</a></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[详细理解JS闭包]]></title>
      <url>http://www.foreverz.cn/2016/10/16/%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3JS%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>最近参加面试，错过一个福利很好的公司，很是心痛。我发现很多大型公司都对校招生的项目要求不高，框架基本都没问，但是要求基础扎实，其中就有对闭包的考察，最近仔细钻研了一下，对闭包也有了一些理解，就在这总结一下。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>要了解闭包就要先了解js中的变量。<br>js中有全局变量和局部变量。其中可以在任意位置访问和修改的就是全局变量。在函数中用var声明的只能在函数内访问和修改的就是局部变量（let和var在函数中声明的变量作用是一样的，这里就不单列出来了）。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>局部变量必须用var关键字来声明，否则会自动添加到全局对象的属性上去，成为全局变量。</li>
<li>全局变量是一直存在的，你用或者不用，他就在那里。而局部变量只有在调用函数的时候才会存在，函数调用过后变量就会销毁，下一次使用函数的时候会重新创建。</li>
</ol>
<h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><ol>
<li>函数是可以进行多级嵌套的。</li>
<li>函数里面的子函数可以访问使用它上级定义的变量，不止是上一级，而是像冒泡一样逐层往上查找，找到了就会停止查找，而如果找到全局也没有找到就会报错。</li>
<li><p>函数里调用函数外变量不能用var，否则就是声明同名局部变量，对函数外变量不会有影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line">a();</div><div class="line"><span class="built_in">console</span>.log(x);</div></pre></td></tr></table></figure>
<p> 结果会先输出2，再输出1。这是因为在函数a里用<code>var</code>重新声明了一个局部变量x并赋值为2，此时在函数a中的变量x和全局变量x是没有关系的。所以调用函数a输出的是局部变量，结果为2，而最下面则输出的是全局变量，结果为1.</p>
</li>
<li><p>函数自调：函数除了上面用<code>a()</code>这样调用外，还可以自调，可以用()把函数包裹起来，后面跟上()执行这个函数。为什么包裹起来呢？因为不包裹那么就是对函数的声明，包裹起来就是一个表达式了，js会直接执行表达式，所以还可以在函数前加”~”、”+”、”-“等符号,函数后跟()让函数自调,但这些符号有很多局限，所以不是很了解的话还是少用。</p>
</li>
<li><p><strong>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</strong><br>其实这句话就是前面第三条，但是很重要，特别提出来，闭包的实现主要也是因为这个原因。</p>
</li>
<li><p>JavaScript中有回收机制，函数被引用执行完成后不再被引用，这个函数的作用域就会被回收销毁，如果两个对象互相引用，而不再被第三者所引用，那么这两个互相引用的对象也会被回收。但是两个对象互相引用，且在被第三者引用，那么就不会被回收。闭包的作用就是让这个函数的作用域不会被回收销毁。</p>
</li>
</ol>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包的解释：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>这是说的什么鬼，字都认识，可是合成一句话就一脸懵逼了，还是举个栗子吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        i ++;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = a();</div><div class="line">c(); <span class="comment">//=&gt; 1</span></div><div class="line">c(); <span class="comment">//=&gt; 2</span></div></pre></td></tr></table></figure></p>
<p>这段代码会输出1和2，我们会发现在这段代码中有两个特点：</p>
<pre><code>1. 函数b嵌套在函数a中;
2. 函数a返回函数b;
</code></pre><p>这就是一个最简单的闭包。<br>在执行完<code>var c = a()</code>之后，c其实是指向b的函数，那么<code>c();</code>就相当于在函数<code>a</code>外执行了<code>a</code>里的函数<code>b</code>。函数b被c引用，而c是全局变量，并不会被回收，而b是在a里面的函数，所以最后函数a的作用域就会被保存在内存中而不会被销毁。<br>所以如果把上面的代码修改一下，让全局变量c不引用b，就会释放a的作用域，闭包也就释放了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        i ++;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = a();</div><div class="line">c(); <span class="comment">//=&gt; 1</span></div><div class="line">c(); <span class="comment">//=&gt; 2</span></div><div class="line">c = a();</div><div class="line">c(); <span class="comment">//=&gt; 1</span></div><div class="line">c(); <span class="comment">//=&gt; 2</span></div></pre></td></tr></table></figure>
<p>上面代码在会输出两个1、2、1、2，而不是1、2、3、4，原因就是在第一个闭包形成输出1、2之后，将闭包释放了，然后又形成了一个新的闭包，调用又输出1和2。</p>
<p>还有一个更为常见的闭包写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        i++;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;)();</div><div class="line">a();</div><div class="line">a();</div></pre></td></tr></table></figure>
<p>匿名函数自执行把函数b赋给了a，这个a就是return回去的函数b；执行<code>a();</code>就是执行内函数b，这样就形成了一个闭包。</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>闭包是非常重要的一个概念，利用闭包很多的好处：</p>
<h3 id="保护函数内的变量安全-加强了封装性"><a href="#保护函数内的变量安全-加强了封装性" class="headerlink" title="保护函数内的变量安全,加强了封装性"></a>保护函数内的变量安全,加强了封装性</h3><p>以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。以第一个闭包来说，函数a中的i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。</p>
<h3 id="在内存中维持一个变量，使逻辑连续-用的太多就变成了缺点，占内存"><a href="#在内存中维持一个变量，使逻辑连续-用的太多就变成了缺点，占内存" class="headerlink" title="在内存中维持一个变量，使逻辑连续(用的太多就变成了缺点，占内存)"></a>在内存中维持一个变量，使逻辑连续(用的太多就变成了缺点，占内存)</h3><p>依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。</p>
<h3 id="实现JS私有属性和私有方法"><a href="#实现JS私有属性和私有方法" class="headerlink" title="实现JS私有属性和私有方法"></a>实现JS私有属性和私有方法</h3><p>通过保护函数内变量的安全，可以利用面向对象的方法创建函数的私有属性和私有方法，且不能被Constructor外访问到。</p>
<h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><p>闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;;</div><div class="line">    a(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子会创建10000个闭包，存在内存中不会释放，会造成内存的极大浪费，所以闭包要慎用。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="解决for循环后执行输出全为循环后值的问题。"><a href="#解决for循环后执行输出全为循环后值的问题。" class="headerlink" title="解决for循环后执行输出全为循环后值的问题。"></a>解决for循环后执行输出全为循环后值的问题。</h3><p>面试题，结果是什么？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个就是我之前遇到过的一个面试题，答案当然很简单，是3个4，不了解的童鞋可以去看一下定时器的运行机制。<br>那么怎么能让它输出1，2，3呢？<br>这个当然有很多的方法，我们这里用闭包来做。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;;</div><div class="line">    a(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个函数就是使用闭包实现了输出1,2,3；在这里a就是外包函数，setTimeout的回调函数就是内函数，而setTimeout就是在外部对内函数的调用。所以这里其实有3个闭包，每个闭包函数被调用了一次，然后就释放掉了。<br>这个函数还可以简化一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">    + <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是用了函数自调来实现的闭包，同样有3个闭包，那么怎么使用1个闭包来实现呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(a++);</div><div class="line">        &#125;, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>这里就是用了1个闭包实现了输出1,2,3；这里的a是内部变量，然后for循环和setTimeout是对内函数的3次外部调用。</p>
<h3 id="利用闭包模拟对象的私有属性"><a href="#利用闭包模拟对象的私有属性" class="headerlink" title="利用闭包模拟对象的私有属性"></a>利用闭包模拟对象的私有属性</h3><p>JavaScript以前缺少块级作用域，没有private修饰符，但是具有函数作用域。作用域的好处是内部函数可以访问它们的外部函数的参数和变量（除了this和argument。内部中的函数中的this指向全局对象，argument指向内部函数的函数参数）。我们可以利用这种属性来模拟面向对象中的私有属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">aname</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> aname = aname || <span class="string">'No Input'</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        get name() &#123;</div><div class="line">            <span class="keyword">return</span> aname;</div><div class="line">        &#125;,</div><div class="line">        set name(newNmae) &#123;</div><div class="line">            aname = newNmae;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fun = test();</div><div class="line"><span class="built_in">console</span>.log(fun.name);	<span class="comment">//=&gt;No Input</span></div><div class="line">fun.name = <span class="string">"mervyn"</span>;</div><div class="line"><span class="built_in">console</span>.log(fun.name);	<span class="comment">//=&gt;mervyn</span></div></pre></td></tr></table></figure></p>
<p>在这里利用闭包和访问器属性模拟出了对象的私有属性的读取与修改。</p>
<h3 id="利用闭包模拟对象的私有方法"><a href="#利用闭包模拟对象的私有方法" class="headerlink" title="利用闭包模拟对象的私有方法"></a>利用闭包模拟对象的私有方法</h3><p>模拟私有方法和模拟私有属相差不多，不过返回的直接是函数而不是访问器而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">aname</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> aname = aname || <span class="string">'No Input'</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> aname;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</div><div class="line">            aname = newName;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fun = test();</div><div class="line"><span class="built_in">console</span>.log(fun.getName());	<span class="comment">//=&gt;No Input</span></div><div class="line">fun.setName(<span class="string">'mervyn'</span>);</div><div class="line"><span class="built_in">console</span>.log(fun.getName());	<span class="comment">//=&gt;mervyn</span></div></pre></td></tr></table></figure></p>
<p>在这里利用闭包直接返回多个函数模拟出了对象的私有方法，可以再外部直接调用，像调用对象方法一样使用。</p>
<p>更多闭包的应用请参考<a href="http://www.cnblogs.com/star-studio/archive/2011/06/22/2086493.html" target="_blank" rel="external">这里</a>;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>闭包是一种非常强大的设计原则，在js中学会使用闭包是非常重要的，使用闭包可以大大简化用户的调用，达到目的。</li>
<li>不需要知道闭包的原理和细节，只要知道闭包的基本使用就可以了。</li>
<li>尽量少学习。</li>
</ol>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js的nodegrass网页请求模块]]></title>
      <url>http://www.foreverz.cn/2016/10/09/Node-js%E7%9A%84nodegrass%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Node.js的网页请求有官方提供的的http模块，但是用起来过于繁琐与复杂，所以有了第三方基于http封装的nodegrass模块，简单易懂，方便使用。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h2 id="nodegrass是什么？"><a href="#nodegrass是什么？" class="headerlink" title="nodegrass是什么？"></a>nodegrass是什么？</h2><p>模块开发者的介绍是：nodegrass is a tool to process client request for Node.js，翻译过来就是nodegress是为Node.js处理客户端请求的工具。是对Node.js官方提供的http模块的二次处理封装，使Node.js更加的易于使用，下面我们就来看看nodegrass的用法。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先是nodegrass的安装方法，可以直接使用npm安装,建议安装在项目文件夹里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install nodegrass -save</div></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>然后就介绍Node.js的使用了。<br>下面是开发者提供的Demo,首先是get请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get request</span></div><div class="line"><span class="keyword">var</span> nodegrass = <span class="built_in">require</span>(<span class="string">'nodegrass'</span>);</div><div class="line">nodegrass.get(<span class="string">"https://github.com"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status,headers</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(status);</div><div class="line">    <span class="built_in">console</span>.log(headers);</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;,<span class="literal">null</span>,<span class="string">'utf8'</span>).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Got error: "</span> + e.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>首先<code>require</code>加载模块，然后就可以直接使用了。这里是get的<code>https://github.com</code>网站</p>
<p>post请求<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ng=<span class="built_in">require</span>(<span class="string">'nodegrass'</span>);</div><div class="line">ng.post(<span class="string">"https://api.weibo.com/oauth2/access_token"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status,headers</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> accessToken = <span class="built_in">JSON</span>.parse(data);</div><div class="line">	<span class="keyword">var</span> err = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">if</span>(accessToken.error)&#123;</div><div class="line">     	err = accessToken;</div><div class="line"> &#125;</div><div class="line"> callback(err,accessToken);</div><div class="line"> &#125;,headers,options,<span class="string">'utf8'</span>);</div></pre></td></tr></table></figure></p>
<p>post方法相比get方法多提供了headers请求头参数，options–post的数据，它们都是对象字面量的类型：</p>
<p>var headers = {<br>    ‘Content-Type’: ‘application/x-www-form-urlencoded’,<br>    ‘Content-Length’:data.length<br>};</p>
<p>var options = {<br>         client_id : ‘id’,<br>     client_secret : ‘cs’,<br>     grant_type : ‘authorization_code’,<br>     redirect_uri : ‘your callback url’,<br>     code: acode<br>};</p>
<p>利用nodegrass做代理服务器？……**</p>
<p>看例子：</p>
<p>var ng = require(‘nodegrass’),<br> http=require(‘http’),<br> url=require(‘url’);</p>
<p> http.createServer(function(req,res){<br>    var pathname = url.parse(req.url).pathname;</p>
<pre><code>if(pathname === &apos;/&apos;){
    ng.get(&apos;http://www.cnblogs.com/&apos;,function(data){
        res.writeHeader(200,{&apos;Content-Type&apos;:&apos;text/html;charset=utf-8&apos;});
        res.write(data+&quot;\n&quot;);
        res.end();
        },&apos;utf8&apos;);
    }
</code></pre><p> }).listen(8088);<br> console.log(‘server listening 8088…’);<br>就这么简单，当然代理服务器还有复杂的多，这个不算是，但至少你访问本地8088端口，看到的是不是博客园的页面呢？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js的FileSystem文件模块]]></title>
      <url>http://www.foreverz.cn/2016/10/04/Node-js%E7%9A%84fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>FileSystem模块是类似UNIX（POSIX）标准的文件操作API，用于操作文件系统——读写目录、读写文件——Node.js底层使用C程序来实现，这些功能是客户端JS所不具备的。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>Nodejs导入文件系统模块(fs)语法如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>Node.js文件系统（fs模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。同步则没有回调函数。<br>建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.open(path,flags[,mode],[callback(err,data)]);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<ul>
<li>path - 文件的路径。</li>
<li>mode - 设置文件模式(权限)，文件创建默认权限为0666(可读，可写)。</li>
<li>callback - 回调函数，带有两个参数如：callback(err,fd)。</li>
<li>flags - 文件打开的行为。具体如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">flag</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td>以读取模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td style="text-align:center">r+</td>
<td>以读写模式打开文件。如果文件不存在抛出异常。</td>
</tr>
<tr>
<td style="text-align:center">rs</td>
<td>以同步的方式读取文件。</td>
</tr>
<tr>
<td style="text-align:center">rs+</td>
<td>以同步的方式读取和写入文件。</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td>以写入模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">wx</td>
<td>类似 ‘w’，但是如果文件路径存在，则文件写入失败。</td>
</tr>
<tr>
<td style="text-align:center">w+</td>
<td>以读写模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">wx+</td>
<td>类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td>以追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">ax</td>
<td>类似 ‘a’， 但是如果文件路径存在，则文件追加失败。</td>
</tr>
<tr>
<td style="text-align:center">a+</td>
<td>以读取追加模式打开文件，如果文件不存在则创建。</td>
</tr>
<tr>
<td style="text-align:center">ax+</td>
<td>类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。</td>
</tr>
</tbody>
</table>
<h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.stat(path,[callback(err,stats)]);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<p><code>fs.stat(path)</code>执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。<br>stats类中的方法有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">stats.isFile()</td>
<td>如果是文件返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isDirectory()</td>
<td>如果是目录返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isBlockDevice()</td>
<td>如果是块设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isCharacterDevice()</td>
<td>如果是字符设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isSymbolicLink()</td>
<td>如果是软链接返回 true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">stats.isFIFO()</td>
<td>如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
</tr>
<tr>
<td style="text-align:left">stats.isSocket()</td>
<td>如果是 Socket 返回 true，否则返回 false。</td>
</tr>
</tbody>
</table>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(filename,data[,options],[callback]);<span class="comment">//异步</span></div><div class="line">fs.writeFileSync(filename,data); <span class="comment">//同步</span></div></pre></td></tr></table></figure></p>
<p>如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
<ul>
<li>data  -要写入文件的数据，可以是String(字符串)或Buffer(流)对象。</li>
<li>options - 该参数是一个对象，包含{encoding,mode,flag}。默认编码为utf8,模式为0666，flag为’w’;</li>
</ul>
<h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.appendFile(filename,data[,options],[callback]);<span class="comment">//同步</span></div><div class="line">fs.appendFileSync(filename,data[,options]); <span class="comment">//同步</span></div></pre></td></tr></table></figure></p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.read(fd,buffer,offset,length,position,[callback]);<span class="comment">//异步</span></div><div class="line"><span class="keyword">var</span> buf = fs.readFile(filename,[encoding],[callback(err,data)]);<span class="comment">//异步读取</span></div><div class="line"><span class="keyword">var</span> buf = fs.readFileSync(filename,[encoding]);<span class="comment">//同步读取</span></div></pre></td></tr></table></figure></p>
<ul>
<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>
<li>buffer - 数据写入的缓冲区。</li>
<li>offset - 缓冲区写入的写入偏移量。</li>
<li>length - 要从文件中读取的字节数。</li>
<li>position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li>encoding，编码格式，该项是可选的。</li>
</ul>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.close(fd,callback);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<ul>
<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>
</ul>
<h2 id="截取文件"><a href="#截取文件" class="headerlink" title="截取文件"></a>截取文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.ftruncate(fd,len,callback);<span class="comment">//异步</span></div></pre></td></tr></table></figure></p>
<ul>
<li>fd - 通过 fs.open() 方法返回的文件描述符。</li>
<li>len - 文件内容截取的长度。</li>
</ul>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.unlink(path,callback);</div></pre></td></tr></table></figure></p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(path[,mode],callback);</div></pre></td></tr></table></figure></p>
<ul>
<li>mode - 设置目录权限，默认为 0777。</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.readdir(path,callback);</div></pre></td></tr></table></figure></p>
<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.rmdir(path,callback);</div></pre></td></tr></table></figure></p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[canvas画Material风格的loadingView]]></title>
      <url>http://www.foreverz.cn/2016/10/03/loadingView/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>之前看到一个撸Material风格的loadingView的<a href="http://androidwing.net/index.php/73" target="_blank" rel="external">文章</a>，里面也有一个SVG做出来效果的<a href="https://material.uplabs.com/posts/material-loader-interface" target="_blank" rel="external">Demo</a>,个人觉得也很好玩，就顺手也做了一个。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>开头上源码和效果：</p>
<p> </p><p data-height="265" data-theme-id="0" data-slug-hash="GjrzXK" data-default-tab="js,result" data-user="foreveryuan" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/foreveryuan/pen/GjrzXK/" target="_blank" rel="external">loadingView</a> by Mervyn (<a href="http://codepen.io/foreveryuan" target="_blank" rel="external">@foreveryuan</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>大家也可以直接去我的github上查看源码:<a href="https://github.com/zmyforever1/loadingView" target="_blank" rel="external">传送门</a>;</p>
<p>这个使用canvas实现的动画效果，svg实现可以去看上面的链接，下面就来看看用canvas的实现。</p>
<h2 id="canvas三剑客"><a href="#canvas三剑客" class="headerlink" title="canvas三剑客"></a>canvas三剑客</h2><p>使用canvas最先登场的当然就是canvas三剑客了，先在HTML添加canvas标签，设置好宽高，然后在JS里获取DOM对象，然后使用画布方法。</p>
<h2 id="第一步，画圆"><a href="#第一步，画圆" class="headerlink" title="第一步，画圆"></a>第一步，画圆</h2><p>最先开始画两个圆。圆的颜色是白色的，所以先在CSS中把背景改为蓝色才能显示出来。<br></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> can = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</div><div class="line"><span class="keyword">var</span> ctx = can.getContext(<span class="string">"2d"</span>);</div><div class="line"><span class="keyword">var</span> mWidth = canvas.width; <span class="comment">//画布的宽</span></div><div class="line"><span class="keyword">var</span> mHeight = canvas.height; <span class="comment">//画布的高</span></div><div class="line"><span class="keyword">var</span> mMaxOffset = <span class="number">150</span>; <span class="comment">//圆最大偏移量</span></div><div class="line"><span class="keyword">var</span> mMaxRadius = <span class="number">30</span>; <span class="comment">//圆半径</span></div><div class="line"><span class="keyword">var</span> mColor = <span class="string">'#fff'</span>; <span class="comment">//颜色</span></div><div class="line"><span class="keyword">var</span> mOffset = <span class="number">0</span>; <span class="comment">//偏移量</span></div><div class="line"><span class="keyword">var</span> mDegrees = <span class="number">0</span>; <span class="comment">//画布转角</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.arc(mWidth / <span class="number">2</span>, mHeight / <span class="number">2</span> - mOffset, mMaxRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>); <span class="comment">//在中心点上方mOffset处画圆</span></div><div class="line">    ctx.closePath();</div><div class="line">    ctx.fillStyle = mColor;</div><div class="line">    ctx.fill();</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.arc(mWidth / <span class="number">2</span>, mHeight / <span class="number">2</span> + mOffset, mMaxRadius, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>); <span class="comment">//在中心点下方mOffset处画圆</span></div><div class="line">    ctx.closePath();</div><div class="line">    ctx.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时画布上会出现一个圆，因为这时这两个圆是重合在一起的。</p>
<h2 id="第二步，旋转"><a href="#第二步，旋转" class="headerlink" title="第二步，旋转"></a>第二步，旋转</h2><p>那接下来就是要使画布旋转起来。这时就需要用到定时器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    drawCircle();</div><div class="line">    rotate();</div><div class="line">    <span class="keyword">var</span> present = mDegrees / <span class="number">360</span>;</div><div class="line">    <span class="keyword">if</span> (present &lt; <span class="number">0.5</span>) &#123;</div><div class="line">        mOffset = mMaxOffset * present; <span class="comment">//改变圆心位置，使其靠近中心点</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mOffset = mMaxOffset * (<span class="number">1</span> - present);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">30</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    canvas.style.transform = <span class="string">`rotate(<span class="subst">$&#123;mDegrees&#125;</span>deg)`</span>; <span class="comment">//使canvas旋转</span></div><div class="line">    mDegrees += <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (mDegrees == <span class="number">360</span>) &#123;</div><div class="line">        mDegrees = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>rotate()</code>函数改变旋转角度，然后使用定时器不停的使画布旋转起来。<br>并且在定时器中对画布旋转角度进行了判断，如果画布转角小于180deg，则使两个圆的偏移量增大，当大于180deg时，则让两个圆的偏移量减小。这时其实会看到两个圆和画布一起在旋转。</p>
<h2 id="第三步，粘合动画"><a href="#第三步，粘合动画" class="headerlink" title="第三步，粘合动画"></a>第三步，粘合动画</h2><p>最后就是绘制两个圆在靠近和分开时的粘合动画了。这里用到了canvas方法里的绘制二次贝塞尔曲线quadraticCurveTo方法;<br>首先在定时器最后加上这句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (present &lt;= <span class="number">0.375</span> || present &gt;= <span class="number">0.625</span>) drawPath(present); <span class="comment">//当两圆接触时绘制粘合动画</span></div></pre></td></tr></table></figure></p>
<p>然后，就是粘合动画函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawPath</span>(<span class="params">present</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> suppoetOffset = -mMaxRadius;</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.moveTo(mWidth / <span class="number">2</span> - mMaxRadius, mHeight / <span class="number">2</span> - mOffset); <span class="comment">//从上圆最左点开始画线</span></div><div class="line">    ctx.lineTo(mWidth / <span class="number">2</span> + mMaxRadius, mHeight / <span class="number">2</span> - mOffset); <span class="comment">//到上圆最右点</span></div><div class="line">    <span class="keyword">if</span> (present &lt; <span class="number">0.25</span> || present &gt; <span class="number">0.75</span>) &#123; <span class="comment">//当两球相交</span></div><div class="line">        suppoetOffset = mMaxRadius;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (present &lt;= <span class="number">0.375</span>) &#123; <span class="comment">//当两球刚分离时</span></div><div class="line">        suppoetOffset = -(<span class="number">480</span> * present - <span class="number">150</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (present &gt;= <span class="number">0.625</span>) &#123; <span class="comment">//当两球快要接触时</span></div><div class="line">        suppoetOffset = <span class="number">480</span> * present - <span class="number">330</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 贝塞尔选点以中心点便宜30以内距离为控制点，另一圆边点为结束点</span></div><div class="line">    ctx.quadraticCurveTo(mWidth / <span class="number">2</span> + suppoetOffset, mHeight / <span class="number">2</span>, mWidth / <span class="number">2</span> + mMaxRadius, mHeight / <span class="number">2</span> + mOffset);</div><div class="line">    ctx.lineTo(mWidth / <span class="number">2</span> - mMaxRadius, mHeight / <span class="number">2</span> + mOffset);</div><div class="line">    ctx.quadraticCurveTo(mWidth / <span class="number">2</span> - suppoetOffset, mHeight / <span class="number">2</span>, mWidth / <span class="number">2</span> - mMaxRadius, mHeight / <span class="number">2</span> - mOffset);</div><div class="line">    ctx.closePath();</div><div class="line">    ctx.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是在两个球的左右四个点用直线和贝塞尔曲线连接起来，形成一个曲四边形，然后随着两球的距离不停的改变两个曲线的控制点，形成动态的粘合动画效果。<br>好了，到此结束，就完成了一个Material风格的loading动画。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://www.foreverz.cn/2016/10/02/Sublime%20Text3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS实现随机颜色的三种方式和颜色格式的转化]]></title>
      <url>http://www.foreverz.cn/2016/09/29/js%E9%9A%8F%E6%9C%BA%E9%A2%9C%E8%89%B2/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>前端的颜色表示方式多种，一种是以3个或6个十六进制的数子表示，一种是RGB的数字形式，还有一种是直接以颜色的英文来表示。这三种都是不支持透明色的。所以还有RGBA的表式方式，在RGB的的基础上加入了Alpha透明，使网页可以展现更加复杂绚丽的效果。<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="随机颜色"><a href="#随机颜色" class="headerlink" title="随机颜色"></a>随机颜色</h2><p>在平时的码农日常中，经常会用到求随机颜色的地方，下面是我总结的几种简单的实现随机颜色的方式：</p>
<h3 id="十六进制格式（-000000-FFFFFF）"><a href="#十六进制格式（-000000-FFFFFF）" class="headerlink" title="十六进制格式（#000000-#FFFFFF）"></a>十六进制格式（#000000-#FFFFFF）</h3><p>第一种是比较简单的方法，这种方法是先随机生成ffffff以内16进制数，然后判断位数，少于6位的用while循环在前面加0，凑够6位。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomHexColor</span>(<span class="params"></span>) </span>&#123; <span class="comment">//随机生成十六进制颜色</span></div><div class="line">    <span class="keyword">var</span> hex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">16777216</span>).toString(<span class="number">16</span>); <span class="comment">//生成ffffff以内16进制数</span></div><div class="line">    <span class="keyword">while</span> (hex.length &lt; <span class="number">6</span>) &#123; <span class="comment">//while循环判断hex位数，少于6位前面加0凑够6位</span></div><div class="line">        hex = <span class="string">'0'</span> + hex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'#'</span> + hex; <span class="comment">//返回‘#’开头16进制颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有一种比较方便但是比较难懂的方法，需要用到位运算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomHexColor</span>(<span class="params"></span>) </span>&#123;	<span class="comment">//随机生成十六进制颜色</span></div><div class="line">	<span class="keyword">return</span> <span class="string">'#'</span> + (<span class="string">'00000'</span> + (<span class="built_in">Math</span>.random() * <span class="number">0x1000000</span> &lt;&lt; <span class="number">0</span>).toString(<span class="number">16</span>)).substr(<span class="number">-6</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按执行顺序可以分为以下六步：</p>
<ol>
<li>先执行<code>Math.random() * 0x1000000</code>，其中0x1000000=0xffffff+1，因为Math.random()取不到1，所以+1，这样就会生成一个1-16777216(不包含)以内的浮点数。</li>
<li>然后执行<code>&lt;&lt;0</code>，这是取整运算，去掉后面的小数点。这时为一个16777216(不包含)以内的十进制数。</li>
<li>之后执行<code>.toString(16)</code>，把十进制数转化为六位以下16进制数。</li>
<li>再后执行<code>&#39;00000&#39;+</code>，这时因为之前生成的16进制数最少可能仅一位，在前面加上5个0。</li>
<li>最后执行<code>.substr(-6)</code>，是去从-6开始的后面所有字符串，也就是最后6位数。</li>
<li>前面加上<code>#</code>并<code>retuen</code>。</li>
</ol>
<h3 id="RGB格式"><a href="#RGB格式" class="headerlink" title="RGB格式"></a>RGB格式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRgbColor</span>(<span class="params"></span>) </span>&#123; <span class="comment">//随机生成RGB颜色</span></div><div class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span></div><div class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span></div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span></div><div class="line">    <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>; <span class="comment">//返回rgb(r,g,b)格式颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RGBA格式"><a href="#RGBA格式" class="headerlink" title="RGBA格式"></a>RGBA格式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRgbaColor</span>(<span class="params"></span>) </span>&#123; <span class="comment">//随机生成RGBA颜色</span></div><div class="line">    <span class="keyword">var</span> r = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span></div><div class="line">    <span class="keyword">var</span> g = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span></div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span></div><div class="line">    <span class="keyword">var</span> alpha = <span class="built_in">Math</span>.random(); <span class="comment">//随机生成1以内a值</span></div><div class="line">    <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;alpha&#125;</span>)`</span>; <span class="comment">//返回rgba(r,g,b,a)格式颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="颜色格式转化"><a href="#颜色格式转化" class="headerlink" title="颜色格式转化"></a>颜色格式转化</h2><p>在编码过程中，经常会遇到要将颜色格式相互转化的问题,其中十六进制格式和RGB格式是可以相互转化的，但是RGBA格式由于多了前两者没有的Alpha透明属性，所以和前两者转化会丢失Alpha值，不建议进行转化，下面是我的颜色转化的方法：</p>
<h3 id="十六进制转为RGB"><a href="#十六进制转为RGB" class="headerlink" title="十六进制转为RGB"></a>十六进制转为RGB</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex2Rgb</span>(<span class="params">hex</span>) </span>&#123; <span class="comment">//十六进制转为RGB</span></div><div class="line">    <span class="keyword">var</span> rgb = []; <span class="comment">// 定义rgb数组</span></div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^\#[0-9A-F]&#123;3&#125;$/i</span>.test(hex)) &#123; <span class="comment">//判断传入是否为#三位十六进制数</span></div><div class="line">        <span class="keyword">let</span> sixHex = <span class="string">'#'</span>;</div><div class="line">        hex.replace(<span class="regexp">/[0-9A-F]/ig</span>, <span class="function"><span class="keyword">function</span>(<span class="params">kw</span>) </span>&#123;</div><div class="line">            sixHex += kw + kw; <span class="comment">//把三位16进制数转化为六位</span></div><div class="line">        &#125;);</div><div class="line">        hex = sixHex; <span class="comment">//保存回hex</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^#[0-9A-F]&#123;6&#125;$/i</span>.test(hex)) &#123; <span class="comment">//判断传入是否为#六位十六进制数</span></div><div class="line">        hex.replace(<span class="regexp">/[0-9A-F]&#123;2&#125;/ig</span>, <span class="function"><span class="keyword">function</span>(<span class="params">kw</span>) </span>&#123;</div><div class="line">            rgb.push(<span class="built_in">eval</span>(<span class="string">'0x'</span> + kw)); <span class="comment">//十六进制转化为十进制并存如数组</span></div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;rgb.join(<span class="string">','</span>)&#125;</span>)`</span>; <span class="comment">//输出RGB格式颜色</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Input <span class="subst">$&#123;hex&#125;</span> is wrong!`</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">'rgb(0,0,0)'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RGB转为十六进制"><a href="#RGB转为十六进制" class="headerlink" title="RGB转为十六进制"></a>RGB转为十六进制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rgb2Hex</span>(<span class="params">rgb</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^rgb\((\d&#123;1,3&#125;\,)&#123;2&#125;\d&#123;1,3&#125;\)$/i</span>.test(rgb)) &#123; <span class="comment">//test RGB</span></div><div class="line">        <span class="keyword">var</span> hex = <span class="string">'#'</span>; <span class="comment">//定义十六进制颜色变量</span></div><div class="line">        rgb.replace(<span class="regexp">/\d&#123;1,3&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">kw</span>) </span>&#123; <span class="comment">//提取rgb数字</span></div><div class="line">            kw = <span class="built_in">parseInt</span>(kw).toString(<span class="number">16</span>); <span class="comment">//转为十六进制</span></div><div class="line">            kw = kw.length &lt; <span class="number">2</span> ? <span class="number">0</span> + kw : kw; <span class="comment">//判断位数，保证两位</span></div><div class="line">            hex += kw; <span class="comment">//拼接</span></div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> hex; <span class="comment">//返回十六进制</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Input <span class="subst">$&#123;rgb&#125;</span> is wrong!`</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">'#000'</span>; <span class="comment">//输入格式错误,返回#000</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是我在平时遇到的关于颜色处理方面的问题，大家有遇到什么奇怪的问题和更好的解决方法可以交流沟通一下。</p>
</the>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法]]></title>
      <url>http://www.foreverz.cn/2016/09/27/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>先是使用了为知笔记，接触到Markdown,后来又在github玩起了博客，Markdown就更加必不可少了，在使用为知笔记的过程中，由于为知笔记有很多的bug，自己也是新手，所以用的很不顺手，走了很多的弯路，后来改用sublime编辑，果然好很多，推荐大家也用sublime进行编辑。下面呢是我在用Markdown过程中学到到语法和总结的一些使用心得和方法。持续更新哦！<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>由于我使用了<a href="https://github.com/MOxFIVE/yelee" target="_blank" rel="external">yelee</a>主题，所以显示的效果会不一样哦。</p>
<h2 id="关于标题"><a href="#关于标题" class="headerlink" title="关于标题"></a>关于标题</h2><p>在行首插入 1 到 6个#，分别表示标题 1 到标题 6，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 这是标题1</div><div class="line">## 这是标题2</div><div class="line">### 这是标题3</div><div class="line">#### 这是标题4</div><div class="line">##### 这是标题5</div><div class="line">###### 这是标题6</div></pre></td></tr></table></figure></p>
<p>效果展示：<br><img src="http://p1.bpimg.com/4851/66c2d7412399f8cf.png" alt="标题"></p>
<h2 id="显示文本"><a href="#显示文本" class="headerlink" title="显示文本"></a>显示文本</h2><h3 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h3><p>文本顶格写就会显示普通文本。</p>
<h3 id="超链接文本"><a href="#超链接文本" class="headerlink" title="超链接文本"></a>超链接文本</h3><p>直接输入超链接的URL会自动变成可链接的形式。<br><a href="http://foreverz.cn" target="_blank" rel="external">http://foreverz.cn</a></p>
<h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><pre><code>在行首增加1个tab或者4个空格就可以达到这种效果。
</code></pre><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>在连续几行的开头加入1个tab或者8个空格，这段文本就会形成文本块。还可以多加tab或空格形成层级。</p>
<pre><code>欢迎到访。
    我已经在你的世界路过。
希望您开心快乐每一天。
</code></pre><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><p>使行内部分文字高亮，来强调显示需要用一对反引号``(tab上方的按键)包围起来。<br><code>HTML</code>,<code>CSS</code>,<code>javascript</code>;</p>
<h2 id="粗体、斜体、删除线"><a href="#粗体、斜体、删除线" class="headerlink" title="粗体、斜体、删除线"></a>粗体、斜体、删除线</h2><p>粗体：在文字前后添加 ** (注意符号与文字间不要有空格）<br>斜体：在文字前后添加 *<br>删除线：在文字前后添加 ~~<br>语法和显示效果如下：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果展示</th>
</tr>
</thead>
<tbody>
<tr>
<td>*斜体1*</td>
<td><em>斜体1</em></td>
</tr>
<tr>
<td>_斜体2_</td>
<td><em>斜体2</em></td>
</tr>
<tr>
<td>**粗体1**</td>
<td><strong>粗体1</strong></td>
</tr>
<tr>
<td>__粗体2__</td>
<td><strong>粗体2</strong></td>
</tr>
<tr>
<td>~~删除线~~</td>
<td><del>删除线</del></td>
</tr>
</tbody>
</table>
<p>然后自由搭配也可以实现<strong><em>斜粗体</em></strong>和<strong><em><del>斜粗删除线</del></em></strong>等效果</p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p>[描述](链接地址 悬停显示)，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[我的博客](http://foreverz.cn &apos;forever&apos;)</div></pre></td></tr></table></figure></p>
<p>或者这样表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[我的博客][forever]</div><div class="line">[forever]:http://foreverz.cn &apos;forever&apos;</div><div class="line">[forever]:http://foreverz.cn &quot;forever&quot;</div><div class="line">[forever]:http://foreverz.cn (forever)</div></pre></td></tr></table></figure></p>
<p>这里的三种定义都是完全相同的。这是用到了<strong>URL标识符</strong>，可以达到复用的目的，一般把全文的URL标识符放到文章末尾，这样比较干净，以方便修改。<br>效果展示:<br><a href="http://foreverz.cn" title="forever" target="_blank" rel="external">我的博客</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[![alt](imgSrc &apos;title&apos;)](hrefURL)</div></pre></td></tr></table></figure></p>
<p>alt是在图片加载失败时显示的替代文字，imgSrc是图片的URL，title是鼠标悬停图片上时现实的文本，hrefURL图片的超链接地址。<br>也可以写成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[![alt](imgSrc &apos;title&apos;)][href]</div><div class="line">[href]:hrefURL</div></pre></td></tr></table></figure></p>
<p>这样也是复用的写法。<br>其中，alt，title和href都可以省略，省略后的最简单的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](imgSrc)</div></pre></td></tr></table></figure></p>
<p>或者这样表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">![alt][id]</div><div class="line">[id]:imgSrc &apos;title&apos;</div></pre></td></tr></table></figure></p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">![](http://foreverz.cn/img/avatar.png &apos;forever&apos;)</div><div class="line">[![forever](http://foreverz.cn/img/avatar.png &apos;forever&apos;)](http://foreverz.cn)</div></pre></td></tr></table></figure></p>
<p>效果展示：<br><img src="http://foreverz.cn/img/avatar.png" alt="" title="forever"><br><a href="http://foreverz.cn" target="_blank" rel="external"><img src="http://foreverz.cn/img/avatar.png" alt="forever" title="forever"></a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在行首增加 1. 、 2. 、 3. ，即数字和英文句点, 不要求数字一定要连续，可以都是 1.，后面加一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 有序列表</div><div class="line">1. 有序列表</div><div class="line">4. 有序列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<p>此外还有二级列表和三级列表等，语法如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 有序列表</div><div class="line">	1.1 二级列表</div><div class="line">1. 有序列表</div><div class="line">	2.1 二级列表</div><div class="line">		2.1.1 二级列表</div><div class="line">4. 有序列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ol>
<li>有序列表<br> 1.1 二级列表</li>
<li>有序列表<br> 2.1 二级列表<pre><code>2.1.1 二级列表
</code></pre></li>
<li>有序列表</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在行首增加 * 、+ 或 -，后面跟一个空格，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* 无序列表</div><div class="line">* 无序列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ul>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<p>此外还有二级列表和三级列表等，语法如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 无序列表</div><div class="line">	* 二级列表</div><div class="line">* 无序列表</div><div class="line">	* 二级列表</div><div class="line">		* 三级列表</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ul>
<li>无序列表<ul>
<li>二级列表</li>
</ul>
</li>
<li>无序列表<ul>
<li>二级列表<ul>
<li>三级列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用列表时需要在后面加上空行与其它内容区隔开，否则会被加入最后一个列表里。</p>
</blockquote>
<h3 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h3><p>列表可被转换为任务清单，只要在列表项开头加上<a href="中间有空格"> </a>或者[x],(分别表示已完成和未完成)。<br>语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- [ ]HTML</div><div class="line">- [ ]CSS</div><div class="line">- [x]JavaScript</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<ul>
<li>[ ]HTML</li>
<li>[ ]CSS</li>
<li>[x]JavaScript</li>
</ul>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>Markdown中的转义字符为\，可以转义的有：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>\ 反斜杠</td>
<td>` 反引号</td>
<td>* 星号</td>
<td>_ 下划线</td>
</tr>
<tr>
<td>{ } 大括号</td>
<td>[ ] 中括号</td>
<td>( ) 小括号</td>
<td># 井号</td>
</tr>
<tr>
<td>+ 加号</td>
<td>- 减号</td>
<td>. 英文句号</td>
<td>! 感叹号</td>
</tr>
</tbody>
</table>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| 为知笔记|更新 | 版本 |</div><div class="line">|---------|-----|------|</div><div class="line">| WizNote | Markdown| Latest |</div></pre></td></tr></table></figure>
<p>效果展示：</p>
<table>
<thead>
<tr>
<th>blog</th>
<th>system</th>
<th>theme</th>
</tr>
</thead>
<tbody>
<tr>
<td>github page</td>
<td>hexo</td>
<td>yelee</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用表格必须在前后加上空行与其它内容区隔开，否则表格无效。</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用文本"><a href="#引用文本" class="headerlink" title="引用文本"></a>引用文本</h3><p>在文字前添加 &gt;<br>效果展示：</p>
<blockquote>
<p>如果你无法简洁的表达你的想法，那只说明你还不够了解它。 – 阿尔伯特·爱因斯坦</p>
</blockquote>
<p>多级引用<br>格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;中国</div><div class="line">&gt;&gt;浙江</div><div class="line">&gt;&gt;&gt;杭州</div></pre></td></tr></table></figure></p>
<p>效果展示：</p>
<blockquote>
<p>中国</p>
<blockquote>
<p>浙江</p>
<blockquote>
<p>杭州</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>使用引用时需要在引用后加上空行与其它内容区隔开，否则会被加入引用。</li>
</ul>
<h3 id="引用代码"><a href="#引用代码" class="headerlink" title="引用代码"></a>引用代码</h3><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用一个 ` 将语句包起来。<br>多行则要在代码前后增加 三个反单引号： ```,后面写上所引用的语言<br>格式如下<br>```javascript<br>for (var i = 0; i &lt; 100; i++)<br>{<br>    console.log(“hello markdown!\n”);<br>}<br>效果展示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hello markdown!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h2><p>在任何你想要展示Markdown 笔记目录的地方，添加 [TOC] ， 在阅读模式下，标题1~6样式的内容会被提取出来作为目录，相当于大纲功能。<br><img src="http://p1.bpimg.com/4851/4172c368837ea17b.png" alt=""></p>
</the>]]></content>
    </entry>
    
  
  
</search>
